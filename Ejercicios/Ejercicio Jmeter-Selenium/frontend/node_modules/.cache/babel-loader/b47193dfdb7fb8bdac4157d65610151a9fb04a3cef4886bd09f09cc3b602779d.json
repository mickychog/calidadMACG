{"ast":null,"code":"import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport * as React from 'react';\nimport * as ReactDOM from 'react-dom';\nimport useEventCallback from '@mui/utils/useEventCallback';\nimport useEnhancedEffect from '@mui/utils/useEnhancedEffect';\nimport useLazyRef from '@mui/utils/useLazyRef';\nimport useTimeout from '@mui/utils/useTimeout';\nimport { useRtl } from '@mui/system/RtlProvider';\nimport reactMajor from '@mui/x-internals/reactMajor';\nimport { gridDimensionsSelector, gridColumnsTotalWidthSelector, gridContentHeightSelector, gridHasFillerSelector, gridRowHeightSelector, gridVerticalScrollbarWidthSelector } from \"../dimensions/gridDimensionsSelectors.js\";\nimport { useGridPrivateApiContext } from \"../../utils/useGridPrivateApiContext.js\";\nimport { useGridRootProps } from \"../../utils/useGridRootProps.js\";\nimport { useGridSelector } from \"../../utils/useGridSelector.js\";\nimport { useRunOnce } from \"../../utils/useRunOnce.js\";\nimport { gridVisibleColumnDefinitionsSelector, gridVisiblePinnedColumnDefinitionsSelector, gridColumnPositionsSelector, gridHasColSpanSelector } from \"../columns/gridColumnsSelector.js\";\nimport { gridPinnedRowsSelector, gridRowTreeSelector } from \"../rows/gridRowsSelector.js\";\nimport { useGridVisibleRows, getVisibleRows } from \"../../utils/useGridVisibleRows.js\";\nimport { useGridEventPriority } from \"../../utils/index.js\";\nimport * as platform from \"../../../utils/platform.js\";\nimport { clamp, range } from \"../../../utils/utils.js\";\nimport { gridRowsMetaSelector } from \"../rows/gridRowsMetaSelector.js\";\nimport { getFirstNonSpannedColumnToRender } from \"../columns/gridColumnsUtils.js\";\nimport { gridRenderContextSelector, gridVirtualizationRowEnabledSelector, gridVirtualizationColumnEnabledSelector } from \"./gridVirtualizationSelectors.js\";\nimport { EMPTY_RENDER_CONTEXT } from \"./useGridVirtualization.js\";\nimport { gridRowSpanningHiddenCellsOriginMapSelector } from \"../rows/gridRowSpanningSelectors.js\";\nimport { gridListColumnSelector } from \"../listView/gridListViewSelectors.js\";\nimport { minimalContentHeight } from \"../rows/gridRowsUtils.js\";\nimport { EMPTY_PINNED_COLUMN_FIELDS } from \"../columns/index.js\";\nimport { gridFocusedVirtualCellSelector } from \"./gridFocusedVirtualCellSelector.js\";\nimport { roundToDecimalPlaces } from \"../../../utils/roundToDecimalPlaces.js\";\nimport { isJSDOM } from \"../../../utils/isJSDOM.js\";\nimport { gridRowSelectionManagerSelector } from \"../rowSelection/index.js\";\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nconst MINIMUM_COLUMN_WIDTH = 50;\nvar ScrollDirection = /*#__PURE__*/function (ScrollDirection) {\n  ScrollDirection[ScrollDirection[\"NONE\"] = 0] = \"NONE\";\n  ScrollDirection[ScrollDirection[\"UP\"] = 1] = \"UP\";\n  ScrollDirection[ScrollDirection[\"DOWN\"] = 2] = \"DOWN\";\n  ScrollDirection[ScrollDirection[\"LEFT\"] = 3] = \"LEFT\";\n  ScrollDirection[ScrollDirection[\"RIGHT\"] = 4] = \"RIGHT\";\n  return ScrollDirection;\n}(ScrollDirection || {});\nconst EMPTY_SCROLL_POSITION = {\n  top: 0,\n  left: 0\n};\nexport const EMPTY_DETAIL_PANELS = Object.freeze(new Map());\nconst createScrollCache = (isRtl, rowBufferPx, columnBufferPx, verticalBuffer, horizontalBuffer) => ({\n  direction: ScrollDirection.NONE,\n  buffer: bufferForDirection(isRtl, ScrollDirection.NONE, rowBufferPx, columnBufferPx, verticalBuffer, horizontalBuffer)\n});\nexport const useGridVirtualScroller = () => {\n  const apiRef = useGridPrivateApiContext();\n  const rootProps = useGridRootProps();\n  const {\n    listView\n  } = rootProps;\n  const visibleColumns = useGridSelector(apiRef, () => listView ? [gridListColumnSelector(apiRef)] : gridVisibleColumnDefinitionsSelector(apiRef));\n  const enabledForRows = useGridSelector(apiRef, gridVirtualizationRowEnabledSelector) && !isJSDOM;\n  const enabledForColumns = useGridSelector(apiRef, gridVirtualizationColumnEnabledSelector) && !isJSDOM;\n  const pinnedRows = useGridSelector(apiRef, gridPinnedRowsSelector);\n  const pinnedColumnDefinitions = gridVisiblePinnedColumnDefinitionsSelector(apiRef);\n  const pinnedColumns = listView ? EMPTY_PINNED_COLUMN_FIELDS : pinnedColumnDefinitions;\n  const hasBottomPinnedRows = pinnedRows.bottom.length > 0;\n  const [panels, setPanels] = React.useState(EMPTY_DETAIL_PANELS);\n  const isRtl = useRtl();\n  const rowSelectionManager = useGridSelector(apiRef, gridRowSelectionManagerSelector);\n  const currentPage = useGridVisibleRows(apiRef);\n  const mainRef = apiRef.current.mainElementRef;\n  const scrollerRef = apiRef.current.virtualScrollerRef;\n  const scrollbarVerticalRef = apiRef.current.virtualScrollbarVerticalRef;\n  const scrollbarHorizontalRef = apiRef.current.virtualScrollbarHorizontalRef;\n  const hasColSpan = useGridSelector(apiRef, gridHasColSpanSelector);\n  const isRenderContextReady = React.useRef(false);\n  const rowHeight = useGridSelector(apiRef, gridRowHeightSelector);\n  const contentHeight = useGridSelector(apiRef, gridContentHeightSelector);\n  const columnsTotalWidth = useGridSelector(apiRef, gridColumnsTotalWidthSelector);\n  const needsHorizontalScrollbar = useGridSelector(apiRef, needsHorizontalScrollbarSelector);\n  const verticalScrollbarWidth = useGridSelector(apiRef, gridVerticalScrollbarWidthSelector);\n  const gridHasFiller = useGridSelector(apiRef, gridHasFillerSelector);\n  const previousSize = React.useRef(null);\n  const mainRefCallback = React.useCallback(node => {\n    mainRef.current = node;\n    if (!node) {\n      return undefined;\n    }\n    const initialRect = node.getBoundingClientRect();\n    let lastSize = {\n      width: roundToDecimalPlaces(initialRect.width, 1),\n      height: roundToDecimalPlaces(initialRect.height, 1)\n    };\n    if (!previousSize.current || lastSize.width !== previousSize.current.width && lastSize.height !== previousSize.current.height) {\n      previousSize.current = lastSize;\n      apiRef.current.publishEvent('resize', lastSize);\n    }\n    if (typeof ResizeObserver === 'undefined') {\n      return undefined;\n    }\n    const observer = new ResizeObserver(entries => {\n      const entry = entries[0];\n      if (!entry) {\n        return;\n      }\n      const newSize = {\n        width: roundToDecimalPlaces(entry.contentRect.width, 1),\n        height: roundToDecimalPlaces(entry.contentRect.height, 1)\n      };\n      if (newSize.width === lastSize.width && newSize.height === lastSize.height) {\n        return;\n      }\n      apiRef.current.publishEvent('resize', newSize);\n      lastSize = newSize;\n    });\n    observer.observe(node);\n    if (reactMajor >= 19) {\n      return () => {\n        mainRef.current = null;\n        observer.disconnect();\n      };\n    }\n    return undefined;\n  }, [apiRef, mainRef]);\n\n  /*\n   * Scroll context logic\n   * ====================\n   * We only render the cells contained in the `renderContext`. However, when the user starts scrolling the grid\n   * in a direction, we want to render as many cells as possible in that direction, as to avoid presenting white\n   * areas if the user scrolls too fast/far and the viewport ends up in a region we haven't rendered yet. To render\n   * more cells, we store some offsets to add to the viewport in `scrollCache.buffer`. Those offsets make the render\n   * context wider in the direction the user is going, but also makes the buffer around the viewport `0` for the\n   * dimension (horizontal or vertical) in which the user is not scrolling. So if the normal viewport is 8 columns\n   * wide, with a 1 column buffer (10 columns total), then we want it to be exactly 8 columns wide during vertical\n   * scroll.\n   * However, we don't want the rows in the old context to re-render from e.g. 10 columns to 8 columns, because that's\n   * work that's not necessary. Thus we store the context at the start of the scroll in `frozenContext`, and the rows\n   * that are part of this old context will keep their same render context as to avoid re-rendering.\n   */\n  const scrollPosition = React.useRef(rootProps.initialState?.scroll ?? EMPTY_SCROLL_POSITION);\n  const ignoreNextScrollEvent = React.useRef(false);\n  const previousContextScrollPosition = React.useRef(EMPTY_SCROLL_POSITION);\n  const previousRowContext = React.useRef(EMPTY_RENDER_CONTEXT);\n  const renderContext = useGridSelector(apiRef, gridRenderContextSelector);\n  const focusedVirtualCell = useGridSelector(apiRef, gridFocusedVirtualCellSelector);\n  const scrollTimeout = useTimeout();\n  const frozenContext = React.useRef(undefined);\n  const scrollCache = useLazyRef(() => createScrollCache(isRtl, rootProps.rowBufferPx, rootProps.columnBufferPx, rowHeight * 15, MINIMUM_COLUMN_WIDTH * 6)).current;\n  const updateRenderContext = React.useCallback(nextRenderContext => {\n    if (areRenderContextsEqual(nextRenderContext, apiRef.current.state.virtualization.renderContext)) {\n      return;\n    }\n    const didRowsIntervalChange = nextRenderContext.firstRowIndex !== previousRowContext.current.firstRowIndex || nextRenderContext.lastRowIndex !== previousRowContext.current.lastRowIndex;\n    apiRef.current.setState(state => {\n      return _extends({}, state, {\n        virtualization: _extends({}, state.virtualization, {\n          renderContext: nextRenderContext\n        })\n      });\n    });\n\n    // The lazy-loading hook is listening to `renderedRowsIntervalChange`,\n    // but only does something if we already have a render context, because\n    // otherwise we would call an update directly on mount\n    const isReady = gridDimensionsSelector(apiRef).isReady;\n    if (isReady && didRowsIntervalChange) {\n      previousRowContext.current = nextRenderContext;\n      apiRef.current.publishEvent('renderedRowsIntervalChange', nextRenderContext);\n    }\n    previousContextScrollPosition.current = scrollPosition.current;\n  }, [apiRef]);\n  const triggerUpdateRenderContext = useEventCallback(() => {\n    const scroller = scrollerRef.current;\n    if (!scroller) {\n      return undefined;\n    }\n    const dimensions = gridDimensionsSelector(apiRef);\n    const maxScrollTop = Math.ceil(dimensions.minimumSize.height - dimensions.viewportOuterSize.height);\n    const maxScrollLeft = Math.ceil(dimensions.minimumSize.width - dimensions.viewportInnerSize.width);\n\n    // Clamp the scroll position to the viewport to avoid re-calculating the render context for scroll bounce\n    const newScroll = {\n      top: clamp(scroller.scrollTop, 0, maxScrollTop),\n      left: isRtl ? clamp(scroller.scrollLeft, -maxScrollLeft, 0) : clamp(scroller.scrollLeft, 0, maxScrollLeft)\n    };\n    const dx = newScroll.left - scrollPosition.current.left;\n    const dy = newScroll.top - scrollPosition.current.top;\n    const isScrolling = dx !== 0 || dy !== 0;\n    scrollPosition.current = newScroll;\n    const direction = isScrolling ? directionForDelta(dx, dy) : ScrollDirection.NONE;\n\n    // Since previous render, we have scrolled...\n    const rowScroll = Math.abs(scrollPosition.current.top - previousContextScrollPosition.current.top);\n    const columnScroll = Math.abs(scrollPosition.current.left - previousContextScrollPosition.current.left);\n\n    // PERF: use the computed minimum column width instead of a static one\n    const didCrossThreshold = rowScroll >= rowHeight || columnScroll >= MINIMUM_COLUMN_WIDTH;\n    const didChangeDirection = scrollCache.direction !== direction;\n    const shouldUpdate = didCrossThreshold || didChangeDirection;\n    if (!shouldUpdate) {\n      return renderContext;\n    }\n\n    // Render a new context\n\n    if (didChangeDirection) {\n      switch (direction) {\n        case ScrollDirection.NONE:\n        case ScrollDirection.LEFT:\n        case ScrollDirection.RIGHT:\n          frozenContext.current = undefined;\n          break;\n        default:\n          frozenContext.current = renderContext;\n          break;\n      }\n    }\n    scrollCache.direction = direction;\n    scrollCache.buffer = bufferForDirection(isRtl, direction, rootProps.rowBufferPx, rootProps.columnBufferPx, rowHeight * 15, MINIMUM_COLUMN_WIDTH * 6);\n    const inputs = inputsSelector(apiRef, rootProps, enabledForRows, enabledForColumns);\n    const nextRenderContext = computeRenderContext(inputs, scrollPosition.current, scrollCache);\n\n    // Prevents batching render context changes\n    ReactDOM.flushSync(() => {\n      updateRenderContext(nextRenderContext);\n    });\n    scrollTimeout.start(1000, triggerUpdateRenderContext);\n    return nextRenderContext;\n  });\n  const forceUpdateRenderContext = () => {\n    // skip update if dimensions are not ready and virtualization is enabled\n    if (!gridDimensionsSelector(apiRef).isReady && (enabledForRows || enabledForColumns)) {\n      return;\n    }\n    const inputs = inputsSelector(apiRef, rootProps, enabledForRows, enabledForColumns);\n    const nextRenderContext = computeRenderContext(inputs, scrollPosition.current, scrollCache);\n    // Reset the frozen context when the render context changes, see the illustration in https://github.com/mui/mui-x/pull/12353\n    frozenContext.current = undefined;\n    updateRenderContext(nextRenderContext);\n  };\n  const handleScroll = useEventCallback(() => {\n    if (ignoreNextScrollEvent.current) {\n      ignoreNextScrollEvent.current = false;\n      return;\n    }\n    const nextRenderContext = triggerUpdateRenderContext();\n    apiRef.current.publishEvent('scrollPositionChange', {\n      top: scrollPosition.current.top,\n      left: scrollPosition.current.left,\n      renderContext: nextRenderContext\n    });\n  });\n  const handleWheel = useEventCallback(event => {\n    apiRef.current.publishEvent('virtualScrollerWheel', {}, event);\n  });\n  const handleTouchMove = useEventCallback(event => {\n    apiRef.current.publishEvent('virtualScrollerTouchMove', {}, event);\n  });\n  const getRows = (params = {}) => {\n    if (!params.rows && !currentPage.range) {\n      return [];\n    }\n    const rowTree = gridRowTreeSelector(apiRef);\n    let baseRenderContext = renderContext;\n    if (params.renderContext) {\n      baseRenderContext = params.renderContext;\n      baseRenderContext.firstColumnIndex = renderContext.firstColumnIndex;\n      baseRenderContext.lastColumnIndex = renderContext.lastColumnIndex;\n    }\n    const isLastSection = !hasBottomPinnedRows && params.position === undefined || hasBottomPinnedRows && params.position === 'bottom';\n    const isPinnedSection = params.position !== undefined;\n    let rowIndexOffset;\n    // FIXME: Why is the switch check exhaustiveness not validated with typescript-eslint?\n    // eslint-disable-next-line default-case\n    switch (params.position) {\n      case 'top':\n        rowIndexOffset = 0;\n        break;\n      case 'bottom':\n        rowIndexOffset = pinnedRows.top.length + currentPage.rows.length;\n        break;\n      case undefined:\n        rowIndexOffset = pinnedRows.top.length;\n        break;\n    }\n    const rowModels = params.rows ?? currentPage.rows;\n    const firstRowToRender = baseRenderContext.firstRowIndex;\n    const lastRowToRender = Math.min(baseRenderContext.lastRowIndex, rowModels.length);\n    const rowIndexes = params.rows ? range(0, params.rows.length) : range(firstRowToRender, lastRowToRender);\n    let virtualRowIndex = -1;\n    if (!isPinnedSection && focusedVirtualCell) {\n      if (focusedVirtualCell.rowIndex < firstRowToRender) {\n        rowIndexes.unshift(focusedVirtualCell.rowIndex);\n        virtualRowIndex = focusedVirtualCell.rowIndex;\n      }\n      if (focusedVirtualCell.rowIndex > lastRowToRender) {\n        rowIndexes.push(focusedVirtualCell.rowIndex);\n        virtualRowIndex = focusedVirtualCell.rowIndex;\n      }\n    }\n    const rows = [];\n    const rowProps = rootProps.slotProps?.row;\n    const columnPositions = gridColumnPositionsSelector(apiRef);\n    rowIndexes.forEach(rowIndexInPage => {\n      const {\n        id,\n        model\n      } = rowModels[rowIndexInPage];\n\n      // In certain cases, the state might already be updated and `currentPage.rows` (which sets `rowModels`)\n      // contains stale data.\n      // In that case, skip any further row processing.\n      // See:\n      // - https://github.com/mui/mui-x/issues/16638\n      // - https://github.com/mui/mui-x/issues/17022\n      if (!rowTree[id]) {\n        return;\n      }\n      const rowIndex = (currentPage?.range?.firstRowIndex || 0) + rowIndexOffset + rowIndexInPage;\n\n      // NOTE: This is an expensive feature, the colSpan code could be optimized.\n      if (hasColSpan) {\n        const minFirstColumn = pinnedColumns.left.length;\n        const maxLastColumn = visibleColumns.length - pinnedColumns.right.length;\n        apiRef.current.calculateColSpan({\n          rowId: id,\n          minFirstColumn,\n          maxLastColumn,\n          columns: visibleColumns\n        });\n        if (pinnedColumns.left.length > 0) {\n          apiRef.current.calculateColSpan({\n            rowId: id,\n            minFirstColumn: 0,\n            maxLastColumn: pinnedColumns.left.length,\n            columns: visibleColumns\n          });\n        }\n        if (pinnedColumns.right.length > 0) {\n          apiRef.current.calculateColSpan({\n            rowId: id,\n            minFirstColumn: visibleColumns.length - pinnedColumns.right.length,\n            maxLastColumn: visibleColumns.length,\n            columns: visibleColumns\n          });\n        }\n      }\n      const baseRowHeight = !apiRef.current.rowHasAutoHeight(id) ? apiRef.current.unstable_getRowHeight(id) : 'auto';\n      const isSelected = rowSelectionManager.has(id) && apiRef.current.isRowSelectable(id);\n      let isFirstVisible = false;\n      if (params.position === undefined) {\n        isFirstVisible = rowIndexInPage === 0;\n      }\n      let isLastVisible = false;\n      const isLastVisibleInSection = rowIndexInPage === rowModels.length - 1;\n      if (isLastSection) {\n        if (!isPinnedSection) {\n          const lastIndex = currentPage.rows.length - 1;\n          const isLastVisibleRowIndex = rowIndexInPage === lastIndex;\n          if (isLastVisibleRowIndex) {\n            isLastVisible = true;\n          }\n        } else {\n          isLastVisible = isLastVisibleInSection;\n        }\n      }\n      let currentRenderContext = baseRenderContext;\n      if (frozenContext.current && rowIndexInPage >= frozenContext.current.firstRowIndex && rowIndexInPage < frozenContext.current.lastRowIndex) {\n        currentRenderContext = frozenContext.current;\n      }\n      const isVirtualFocusRow = rowIndexInPage === virtualRowIndex;\n      const isVirtualFocusColumn = focusedVirtualCell?.rowIndex === rowIndex;\n      const offsetLeft = computeOffsetLeft(columnPositions, currentRenderContext, pinnedColumns.left.length);\n      const showBottomBorder = isLastVisibleInSection && params.position === 'top';\n      const firstColumnIndex = currentRenderContext.firstColumnIndex;\n      const lastColumnIndex = currentRenderContext.lastColumnIndex;\n      rows.push(/*#__PURE__*/_jsx(rootProps.slots.row, _extends({\n        row: model,\n        rowId: id,\n        index: rowIndex,\n        selected: isSelected,\n        offsetLeft: offsetLeft,\n        columnsTotalWidth: columnsTotalWidth,\n        rowHeight: baseRowHeight,\n        pinnedColumns: pinnedColumns,\n        visibleColumns: visibleColumns,\n        firstColumnIndex: firstColumnIndex,\n        lastColumnIndex: lastColumnIndex,\n        focusedColumnIndex: isVirtualFocusColumn ? focusedVirtualCell.columnIndex : undefined,\n        isFirstVisible: isFirstVisible,\n        isLastVisible: isLastVisible,\n        isNotVisible: isVirtualFocusRow,\n        showBottomBorder: showBottomBorder,\n        scrollbarWidth: verticalScrollbarWidth,\n        gridHasFiller: gridHasFiller\n      }, rowProps), id));\n      if (isVirtualFocusRow) {\n        return;\n      }\n      const panel = panels.get(id);\n      if (panel) {\n        rows.push(panel);\n      }\n      if (params.position === undefined && isLastVisibleInSection) {\n        rows.push(apiRef.current.getInfiniteLoadingTriggerElement?.({\n          lastRowId: id\n        }));\n      }\n    });\n    return rows;\n  };\n  const scrollerStyle = React.useMemo(() => ({\n    overflowX: !needsHorizontalScrollbar || listView ? 'hidden' : undefined,\n    overflowY: rootProps.autoHeight ? 'hidden' : undefined\n  }), [needsHorizontalScrollbar, rootProps.autoHeight, listView]);\n  const contentSize = React.useMemo(() => {\n    const size = {\n      width: needsHorizontalScrollbar ? columnsTotalWidth : 'auto',\n      flexBasis: contentHeight,\n      flexShrink: 0\n    };\n    if (size.flexBasis === 0) {\n      size.flexBasis = minimalContentHeight; // Give room to show the overlay when there no rows.\n    }\n    return size;\n  }, [columnsTotalWidth, contentHeight, needsHorizontalScrollbar]);\n  const onContentSizeApplied = React.useCallback(node => {\n    if (!node) {\n      return;\n    }\n    apiRef.current.publishEvent('virtualScrollerContentSizeChange', {\n      columnsTotalWidth,\n      contentHeight\n    });\n  }, [apiRef, columnsTotalWidth, contentHeight]);\n  useEnhancedEffect(() => {\n    if (!isRenderContextReady.current) {\n      return;\n    }\n    apiRef.current.updateRenderContext?.();\n  }, [apiRef, enabledForColumns, enabledForRows]);\n  useEnhancedEffect(() => {\n    if (listView) {\n      scrollerRef.current.scrollLeft = 0;\n    }\n  }, [listView, scrollerRef]);\n  useRunOnce(renderContext !== EMPTY_RENDER_CONTEXT, () => {\n    apiRef.current.publishEvent('scrollPositionChange', {\n      top: scrollPosition.current.top,\n      left: scrollPosition.current.left,\n      renderContext\n    });\n    isRenderContextReady.current = true;\n    if (rootProps.initialState?.scroll && scrollerRef.current) {\n      const scroller = scrollerRef.current;\n      const {\n        top,\n        left\n      } = rootProps.initialState.scroll;\n\n      // On initial mount, if we have columns available, we can restore the horizontal scroll immediately, but we need to skip the resulting scroll event, otherwise we would recalculate the render context at position top=0, left=restoredValue, but the initial render context is already calculated based on the initial value of scrollPosition ref.\n      const isScrollRestored = {\n        top: !(top > 0),\n        left: !(left > 0)\n      };\n      if (!isScrollRestored.left && columnsTotalWidth) {\n        scroller.scrollLeft = left;\n        ignoreNextScrollEvent.current = true;\n        isScrollRestored.left = true;\n      }\n\n      // For the sake of completeness, but I'm not sure if contentHeight is ever available at this point. Maybe when virtualisation is disabled?\n      if (!isScrollRestored.top && contentHeight) {\n        scroller.scrollTop = top;\n        ignoreNextScrollEvent.current = true;\n        isScrollRestored.top = true;\n      }\n\n      // To restore the vertical scroll, we need to wait until the rows are available in the DOM (otherwise there's nowhere to scroll), but before paint to avoid reflows\n      if (!isScrollRestored.top || !isScrollRestored.left) {\n        const unsubscribeContentSizeChange = apiRef.current.subscribeEvent('virtualScrollerContentSizeChange', params => {\n          if (!isScrollRestored.left && params.columnsTotalWidth) {\n            scroller.scrollLeft = left;\n            ignoreNextScrollEvent.current = true;\n            isScrollRestored.left = true;\n          }\n          if (!isScrollRestored.top && params.contentHeight) {\n            scroller.scrollTop = top;\n            ignoreNextScrollEvent.current = true;\n            isScrollRestored.top = true;\n          }\n          if (isScrollRestored.left && isScrollRestored.top) {\n            unsubscribeContentSizeChange();\n          }\n        });\n        return unsubscribeContentSizeChange;\n      }\n    }\n    return undefined;\n  });\n  apiRef.current.register('private', {\n    updateRenderContext: forceUpdateRenderContext\n  });\n  useGridEventPriority(apiRef, 'sortedRowsSet', forceUpdateRenderContext);\n  useGridEventPriority(apiRef, 'paginationModelChange', forceUpdateRenderContext);\n  useGridEventPriority(apiRef, 'columnsChange', forceUpdateRenderContext);\n  return {\n    renderContext,\n    setPanels,\n    getRows,\n    getContainerProps: () => ({\n      ref: mainRefCallback\n    }),\n    getScrollerProps: () => ({\n      ref: scrollerRef,\n      onScroll: handleScroll,\n      onWheel: handleWheel,\n      onTouchMove: handleTouchMove,\n      style: scrollerStyle,\n      role: 'presentation',\n      // `tabIndex` shouldn't be used along role=presentation, but it fixes a Firefox bug\n      // https://github.com/mui/mui-x/pull/13891#discussion_r1683416024\n      tabIndex: platform.isFirefox ? -1 : undefined\n    }),\n    getContentProps: () => ({\n      style: contentSize,\n      role: 'presentation',\n      ref: onContentSizeApplied\n    }),\n    getRenderZoneProps: () => ({\n      role: 'rowgroup'\n    }),\n    getScrollbarVerticalProps: () => ({\n      ref: scrollbarVerticalRef,\n      scrollPosition\n    }),\n    getScrollbarHorizontalProps: () => ({\n      ref: scrollbarHorizontalRef,\n      scrollPosition\n    }),\n    getScrollAreaProps: () => ({\n      scrollPosition\n    })\n  };\n};\n// dimension selectors\nfunction needsHorizontalScrollbarSelector(apiRef) {\n  return apiRef.current.state.dimensions.viewportOuterSize.width > 0 && apiRef.current.state.dimensions.columnsTotalWidth > apiRef.current.state.dimensions.viewportOuterSize.width;\n}\nfunction inputsSelector(apiRef, rootProps, enabledForRows, enabledForColumns) {\n  const dimensions = gridDimensionsSelector(apiRef);\n  const currentPage = getVisibleRows(apiRef, rootProps);\n  const visibleColumns = rootProps.listView ? [gridListColumnSelector(apiRef)] : gridVisibleColumnDefinitionsSelector(apiRef);\n  const hiddenCellsOriginMap = gridRowSpanningHiddenCellsOriginMapSelector(apiRef);\n  const lastRowId = apiRef.current.state.rows.dataRowIds.at(-1);\n  const lastColumn = visibleColumns.at(-1);\n  return {\n    enabledForRows,\n    enabledForColumns,\n    apiRef,\n    autoHeight: rootProps.autoHeight,\n    rowBufferPx: rootProps.rowBufferPx,\n    columnBufferPx: rootProps.columnBufferPx,\n    leftPinnedWidth: dimensions.leftPinnedWidth,\n    columnsTotalWidth: dimensions.columnsTotalWidth,\n    viewportInnerWidth: dimensions.viewportInnerSize.width,\n    viewportInnerHeight: dimensions.viewportInnerSize.height,\n    lastRowHeight: lastRowId !== undefined ? apiRef.current.unstable_getRowHeight(lastRowId) : 0,\n    lastColumnWidth: lastColumn?.computedWidth ?? 0,\n    rowsMeta: gridRowsMetaSelector(apiRef),\n    columnPositions: gridColumnPositionsSelector(apiRef),\n    rows: currentPage.rows,\n    range: currentPage.range,\n    pinnedColumns: gridVisiblePinnedColumnDefinitionsSelector(apiRef),\n    visibleColumns,\n    hiddenCellsOriginMap,\n    listView: rootProps.listView ?? false,\n    virtualizeColumnsWithAutoRowHeight: rootProps.virtualizeColumnsWithAutoRowHeight\n  };\n}\nfunction computeRenderContext(inputs, scrollPosition, scrollCache) {\n  const renderContext = {\n    firstRowIndex: 0,\n    lastRowIndex: inputs.rows.length,\n    firstColumnIndex: 0,\n    lastColumnIndex: inputs.visibleColumns.length\n  };\n  const {\n    top,\n    left\n  } = scrollPosition;\n  const realLeft = Math.abs(left) + inputs.leftPinnedWidth;\n  if (inputs.enabledForRows) {\n    // Clamp the value because the search may return an index out of bounds.\n    // In the last index, this is not needed because Array.slice doesn't include it.\n    let firstRowIndex = Math.min(getNearestIndexToRender(inputs, top, {\n      atStart: true,\n      lastPosition: inputs.rowsMeta.positions[inputs.rowsMeta.positions.length - 1] + inputs.lastRowHeight\n    }), inputs.rowsMeta.positions.length - 1);\n\n    // If any of the cells in the `firstRowIndex` is hidden due to an extended row span,\n    // Make sure the row from where the rowSpan is originated is visible.\n    const rowSpanHiddenCellOrigin = inputs.hiddenCellsOriginMap[firstRowIndex];\n    if (rowSpanHiddenCellOrigin) {\n      const minSpannedRowIndex = Math.min(...Object.values(rowSpanHiddenCellOrigin));\n      firstRowIndex = Math.min(firstRowIndex, minSpannedRowIndex);\n    }\n    const lastRowIndex = inputs.autoHeight ? firstRowIndex + inputs.rows.length : getNearestIndexToRender(inputs, top + inputs.viewportInnerHeight);\n    renderContext.firstRowIndex = firstRowIndex;\n    renderContext.lastRowIndex = lastRowIndex;\n  }\n  if (inputs.listView) {\n    return _extends({}, renderContext, {\n      lastColumnIndex: 1\n    });\n  }\n  if (inputs.enabledForColumns) {\n    let firstColumnIndex = 0;\n    let lastColumnIndex = inputs.columnPositions.length;\n    let hasRowWithAutoHeight = false;\n    const [firstRowToRender, lastRowToRender] = getIndexesToRender({\n      firstIndex: renderContext.firstRowIndex,\n      lastIndex: renderContext.lastRowIndex,\n      minFirstIndex: 0,\n      maxLastIndex: inputs.rows.length,\n      bufferBefore: scrollCache.buffer.rowBefore,\n      bufferAfter: scrollCache.buffer.rowAfter,\n      positions: inputs.rowsMeta.positions,\n      lastSize: inputs.lastRowHeight\n    });\n    if (!inputs.virtualizeColumnsWithAutoRowHeight) {\n      for (let i = firstRowToRender; i < lastRowToRender && !hasRowWithAutoHeight; i += 1) {\n        const row = inputs.rows[i];\n        hasRowWithAutoHeight = inputs.apiRef.current.rowHasAutoHeight(row.id);\n      }\n    }\n    if (!hasRowWithAutoHeight || inputs.virtualizeColumnsWithAutoRowHeight) {\n      firstColumnIndex = binarySearch(realLeft, inputs.columnPositions, {\n        atStart: true,\n        lastPosition: inputs.columnsTotalWidth\n      });\n      lastColumnIndex = binarySearch(realLeft + inputs.viewportInnerWidth, inputs.columnPositions);\n    }\n    renderContext.firstColumnIndex = firstColumnIndex;\n    renderContext.lastColumnIndex = lastColumnIndex;\n  }\n  const actualRenderContext = deriveRenderContext(inputs, renderContext, scrollCache);\n  return actualRenderContext;\n}\nfunction getNearestIndexToRender(inputs, offset, options) {\n  const lastMeasuredIndexRelativeToAllRows = inputs.apiRef.current.getLastMeasuredRowIndex();\n  let allRowsMeasured = lastMeasuredIndexRelativeToAllRows === Infinity;\n  if (inputs.range?.lastRowIndex && !allRowsMeasured) {\n    // Check if all rows in this page are already measured\n    allRowsMeasured = lastMeasuredIndexRelativeToAllRows >= inputs.range.lastRowIndex;\n  }\n  const lastMeasuredIndexRelativeToCurrentPage = clamp(lastMeasuredIndexRelativeToAllRows - (inputs.range?.firstRowIndex || 0), 0, inputs.rowsMeta.positions.length);\n  if (allRowsMeasured || inputs.rowsMeta.positions[lastMeasuredIndexRelativeToCurrentPage] >= offset) {\n    // If all rows were measured (when no row has \"auto\" as height) or all rows before the offset\n    // were measured, then use a binary search because it's faster.\n    return binarySearch(offset, inputs.rowsMeta.positions, options);\n  }\n\n  // Otherwise, use an exponential search.\n  // If rows have \"auto\" as height, their positions will be based on estimated heights.\n  // In this case, we can skip several steps until we find a position higher than the offset.\n  // Inspired by https://github.com/bvaughn/react-virtualized/blob/master/source/Grid/utils/CellSizeAndPositionManager.js\n  return exponentialSearch(offset, inputs.rowsMeta.positions, lastMeasuredIndexRelativeToCurrentPage, options);\n}\n\n/**\n * Accepts as input a raw render context (the area visible in the viewport) and adds\n * computes the actual render context based on pinned elements, buffer dimensions and\n * spanning.\n */\nfunction deriveRenderContext(inputs, nextRenderContext, scrollCache) {\n  const [firstRowToRender, lastRowToRender] = getIndexesToRender({\n    firstIndex: nextRenderContext.firstRowIndex,\n    lastIndex: nextRenderContext.lastRowIndex,\n    minFirstIndex: 0,\n    maxLastIndex: inputs.rows.length,\n    bufferBefore: scrollCache.buffer.rowBefore,\n    bufferAfter: scrollCache.buffer.rowAfter,\n    positions: inputs.rowsMeta.positions,\n    lastSize: inputs.lastRowHeight\n  });\n  const [initialFirstColumnToRender, lastColumnToRender] = getIndexesToRender({\n    firstIndex: nextRenderContext.firstColumnIndex,\n    lastIndex: nextRenderContext.lastColumnIndex,\n    minFirstIndex: inputs.pinnedColumns.left.length,\n    maxLastIndex: inputs.visibleColumns.length - inputs.pinnedColumns.right.length,\n    bufferBefore: scrollCache.buffer.columnBefore,\n    bufferAfter: scrollCache.buffer.columnAfter,\n    positions: inputs.columnPositions,\n    lastSize: inputs.lastColumnWidth\n  });\n  const firstColumnToRender = getFirstNonSpannedColumnToRender({\n    firstColumnToRender: initialFirstColumnToRender,\n    apiRef: inputs.apiRef,\n    firstRowToRender,\n    lastRowToRender,\n    visibleRows: inputs.rows\n  });\n  return {\n    firstRowIndex: firstRowToRender,\n    lastRowIndex: lastRowToRender,\n    firstColumnIndex: firstColumnToRender,\n    lastColumnIndex: lastColumnToRender\n  };\n}\n/**\n * Use binary search to avoid looping through all possible positions.\n * The `options.atStart` provides the possibility to match for the first element that\n * intersects the screen, even if said element's start position is before `offset`. In\n * other words, we search for `offset + width`.\n */\nfunction binarySearch(offset, positions, options = undefined, sliceStart = 0, sliceEnd = positions.length) {\n  if (positions.length <= 0) {\n    return -1;\n  }\n  if (sliceStart >= sliceEnd) {\n    return sliceStart;\n  }\n  const pivot = sliceStart + Math.floor((sliceEnd - sliceStart) / 2);\n  const position = positions[pivot];\n  let isBefore;\n  if (options?.atStart) {\n    const width = (pivot === positions.length - 1 ? options.lastPosition : positions[pivot + 1]) - position;\n    isBefore = offset - width < position;\n  } else {\n    isBefore = offset <= position;\n  }\n  return isBefore ? binarySearch(offset, positions, options, sliceStart, pivot) : binarySearch(offset, positions, options, pivot + 1, sliceEnd);\n}\nfunction exponentialSearch(offset, positions, index, options = undefined) {\n  let interval = 1;\n  while (index < positions.length && Math.abs(positions[index]) < offset) {\n    index += interval;\n    interval *= 2;\n  }\n  return binarySearch(offset, positions, options, Math.floor(index / 2), Math.min(index, positions.length));\n}\nfunction getIndexesToRender({\n  firstIndex,\n  lastIndex,\n  bufferBefore,\n  bufferAfter,\n  minFirstIndex,\n  maxLastIndex,\n  positions,\n  lastSize\n}) {\n  const firstPosition = positions[firstIndex] - bufferBefore;\n  const lastPosition = positions[lastIndex] + bufferAfter;\n  const firstIndexPadded = binarySearch(firstPosition, positions, {\n    atStart: true,\n    lastPosition: positions[positions.length - 1] + lastSize\n  });\n  const lastIndexPadded = binarySearch(lastPosition, positions);\n  return [clamp(firstIndexPadded, minFirstIndex, maxLastIndex), clamp(lastIndexPadded, minFirstIndex, maxLastIndex)];\n}\nexport function areRenderContextsEqual(context1, context2) {\n  if (context1 === context2) {\n    return true;\n  }\n  return context1.firstRowIndex === context2.firstRowIndex && context1.lastRowIndex === context2.lastRowIndex && context1.firstColumnIndex === context2.firstColumnIndex && context1.lastColumnIndex === context2.lastColumnIndex;\n}\nexport function computeOffsetLeft(columnPositions, renderContext, pinnedLeftLength) {\n  const left = (columnPositions[renderContext.firstColumnIndex] ?? 0) - (columnPositions[pinnedLeftLength] ?? 0);\n  return Math.abs(left);\n}\nfunction directionForDelta(dx, dy) {\n  if (dx === 0 && dy === 0) {\n    return ScrollDirection.NONE;\n  }\n  /* eslint-disable */\n  if (Math.abs(dy) >= Math.abs(dx)) {\n    if (dy > 0) {\n      return ScrollDirection.DOWN;\n    } else {\n      return ScrollDirection.UP;\n    }\n  } else {\n    if (dx > 0) {\n      return ScrollDirection.RIGHT;\n    } else {\n      return ScrollDirection.LEFT;\n    }\n  }\n  /* eslint-enable */\n}\nfunction bufferForDirection(isRtl, direction, rowBufferPx, columnBufferPx, verticalBuffer, horizontalBuffer) {\n  if (isRtl) {\n    switch (direction) {\n      case ScrollDirection.LEFT:\n        direction = ScrollDirection.RIGHT;\n        break;\n      case ScrollDirection.RIGHT:\n        direction = ScrollDirection.LEFT;\n        break;\n      default:\n    }\n  }\n  switch (direction) {\n    case ScrollDirection.NONE:\n      return {\n        rowAfter: rowBufferPx,\n        rowBefore: rowBufferPx,\n        columnAfter: columnBufferPx,\n        columnBefore: columnBufferPx\n      };\n    case ScrollDirection.LEFT:\n      return {\n        rowAfter: 0,\n        rowBefore: 0,\n        columnAfter: 0,\n        columnBefore: horizontalBuffer\n      };\n    case ScrollDirection.RIGHT:\n      return {\n        rowAfter: 0,\n        rowBefore: 0,\n        columnAfter: horizontalBuffer,\n        columnBefore: 0\n      };\n    case ScrollDirection.UP:\n      return {\n        rowAfter: 0,\n        rowBefore: verticalBuffer,\n        columnAfter: 0,\n        columnBefore: 0\n      };\n    case ScrollDirection.DOWN:\n      return {\n        rowAfter: verticalBuffer,\n        rowBefore: 0,\n        columnAfter: 0,\n        columnBefore: 0\n      };\n    default:\n      // eslint unable to figure out enum exhaustiveness\n      throw new Error('unreachable');\n  }\n}","map":{"version":3,"names":["_extends","React","ReactDOM","useEventCallback","useEnhancedEffect","useLazyRef","useTimeout","useRtl","reactMajor","gridDimensionsSelector","gridColumnsTotalWidthSelector","gridContentHeightSelector","gridHasFillerSelector","gridRowHeightSelector","gridVerticalScrollbarWidthSelector","useGridPrivateApiContext","useGridRootProps","useGridSelector","useRunOnce","gridVisibleColumnDefinitionsSelector","gridVisiblePinnedColumnDefinitionsSelector","gridColumnPositionsSelector","gridHasColSpanSelector","gridPinnedRowsSelector","gridRowTreeSelector","useGridVisibleRows","getVisibleRows","useGridEventPriority","platform","clamp","range","gridRowsMetaSelector","getFirstNonSpannedColumnToRender","gridRenderContextSelector","gridVirtualizationRowEnabledSelector","gridVirtualizationColumnEnabledSelector","EMPTY_RENDER_CONTEXT","gridRowSpanningHiddenCellsOriginMapSelector","gridListColumnSelector","minimalContentHeight","EMPTY_PINNED_COLUMN_FIELDS","gridFocusedVirtualCellSelector","roundToDecimalPlaces","isJSDOM","gridRowSelectionManagerSelector","jsx","_jsx","MINIMUM_COLUMN_WIDTH","ScrollDirection","EMPTY_SCROLL_POSITION","top","left","EMPTY_DETAIL_PANELS","Object","freeze","Map","createScrollCache","isRtl","rowBufferPx","columnBufferPx","verticalBuffer","horizontalBuffer","direction","NONE","buffer","bufferForDirection","useGridVirtualScroller","apiRef","rootProps","listView","visibleColumns","enabledForRows","enabledForColumns","pinnedRows","pinnedColumnDefinitions","pinnedColumns","hasBottomPinnedRows","bottom","length","panels","setPanels","useState","rowSelectionManager","currentPage","mainRef","current","mainElementRef","scrollerRef","virtualScrollerRef","scrollbarVerticalRef","virtualScrollbarVerticalRef","scrollbarHorizontalRef","virtualScrollbarHorizontalRef","hasColSpan","isRenderContextReady","useRef","rowHeight","contentHeight","columnsTotalWidth","needsHorizontalScrollbar","needsHorizontalScrollbarSelector","verticalScrollbarWidth","gridHasFiller","previousSize","mainRefCallback","useCallback","node","undefined","initialRect","getBoundingClientRect","lastSize","width","height","publishEvent","ResizeObserver","observer","entries","entry","newSize","contentRect","observe","disconnect","scrollPosition","initialState","scroll","ignoreNextScrollEvent","previousContextScrollPosition","previousRowContext","renderContext","focusedVirtualCell","scrollTimeout","frozenContext","scrollCache","updateRenderContext","nextRenderContext","areRenderContextsEqual","state","virtualization","didRowsIntervalChange","firstRowIndex","lastRowIndex","setState","isReady","triggerUpdateRenderContext","scroller","dimensions","maxScrollTop","Math","ceil","minimumSize","viewportOuterSize","maxScrollLeft","viewportInnerSize","newScroll","scrollTop","scrollLeft","dx","dy","isScrolling","directionForDelta","rowScroll","abs","columnScroll","didCrossThreshold","didChangeDirection","shouldUpdate","LEFT","RIGHT","inputs","inputsSelector","computeRenderContext","flushSync","start","forceUpdateRenderContext","handleScroll","handleWheel","event","handleTouchMove","getRows","params","rows","rowTree","baseRenderContext","firstColumnIndex","lastColumnIndex","isLastSection","position","isPinnedSection","rowIndexOffset","rowModels","firstRowToRender","lastRowToRender","min","rowIndexes","virtualRowIndex","rowIndex","unshift","push","rowProps","slotProps","row","columnPositions","forEach","rowIndexInPage","id","model","minFirstColumn","maxLastColumn","right","calculateColSpan","rowId","columns","baseRowHeight","rowHasAutoHeight","unstable_getRowHeight","isSelected","has","isRowSelectable","isFirstVisible","isLastVisible","isLastVisibleInSection","lastIndex","isLastVisibleRowIndex","currentRenderContext","isVirtualFocusRow","isVirtualFocusColumn","offsetLeft","computeOffsetLeft","showBottomBorder","slots","index","selected","focusedColumnIndex","columnIndex","isNotVisible","scrollbarWidth","panel","get","getInfiniteLoadingTriggerElement","lastRowId","scrollerStyle","useMemo","overflowX","overflowY","autoHeight","contentSize","size","flexBasis","flexShrink","onContentSizeApplied","isScrollRestored","unsubscribeContentSizeChange","subscribeEvent","register","getContainerProps","ref","getScrollerProps","onScroll","onWheel","onTouchMove","style","role","tabIndex","isFirefox","getContentProps","getRenderZoneProps","getScrollbarVerticalProps","getScrollbarHorizontalProps","getScrollAreaProps","hiddenCellsOriginMap","dataRowIds","at","lastColumn","leftPinnedWidth","viewportInnerWidth","viewportInnerHeight","lastRowHeight","lastColumnWidth","computedWidth","rowsMeta","virtualizeColumnsWithAutoRowHeight","realLeft","getNearestIndexToRender","atStart","lastPosition","positions","rowSpanHiddenCellOrigin","minSpannedRowIndex","values","hasRowWithAutoHeight","getIndexesToRender","firstIndex","minFirstIndex","maxLastIndex","bufferBefore","rowBefore","bufferAfter","rowAfter","i","binarySearch","actualRenderContext","deriveRenderContext","offset","options","lastMeasuredIndexRelativeToAllRows","getLastMeasuredRowIndex","allRowsMeasured","Infinity","lastMeasuredIndexRelativeToCurrentPage","exponentialSearch","initialFirstColumnToRender","lastColumnToRender","columnBefore","columnAfter","firstColumnToRender","visibleRows","sliceStart","sliceEnd","pivot","floor","isBefore","interval","firstPosition","firstIndexPadded","lastIndexPadded","context1","context2","pinnedLeftLength","DOWN","UP","Error"],"sources":["D:/2025/Calidad de Software/calidadMACG/Ejercicios/Ejercicio Jmeter-Selenium/frontend/node_modules/@mui/x-data-grid/esm/hooks/features/virtualization/useGridVirtualScroller.js"],"sourcesContent":["import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport * as React from 'react';\nimport * as ReactDOM from 'react-dom';\nimport useEventCallback from '@mui/utils/useEventCallback';\nimport useEnhancedEffect from '@mui/utils/useEnhancedEffect';\nimport useLazyRef from '@mui/utils/useLazyRef';\nimport useTimeout from '@mui/utils/useTimeout';\nimport { useRtl } from '@mui/system/RtlProvider';\nimport reactMajor from '@mui/x-internals/reactMajor';\nimport { gridDimensionsSelector, gridColumnsTotalWidthSelector, gridContentHeightSelector, gridHasFillerSelector, gridRowHeightSelector, gridVerticalScrollbarWidthSelector } from \"../dimensions/gridDimensionsSelectors.js\";\nimport { useGridPrivateApiContext } from \"../../utils/useGridPrivateApiContext.js\";\nimport { useGridRootProps } from \"../../utils/useGridRootProps.js\";\nimport { useGridSelector } from \"../../utils/useGridSelector.js\";\nimport { useRunOnce } from \"../../utils/useRunOnce.js\";\nimport { gridVisibleColumnDefinitionsSelector, gridVisiblePinnedColumnDefinitionsSelector, gridColumnPositionsSelector, gridHasColSpanSelector } from \"../columns/gridColumnsSelector.js\";\nimport { gridPinnedRowsSelector, gridRowTreeSelector } from \"../rows/gridRowsSelector.js\";\nimport { useGridVisibleRows, getVisibleRows } from \"../../utils/useGridVisibleRows.js\";\nimport { useGridEventPriority } from \"../../utils/index.js\";\nimport * as platform from \"../../../utils/platform.js\";\nimport { clamp, range } from \"../../../utils/utils.js\";\nimport { gridRowsMetaSelector } from \"../rows/gridRowsMetaSelector.js\";\nimport { getFirstNonSpannedColumnToRender } from \"../columns/gridColumnsUtils.js\";\nimport { gridRenderContextSelector, gridVirtualizationRowEnabledSelector, gridVirtualizationColumnEnabledSelector } from \"./gridVirtualizationSelectors.js\";\nimport { EMPTY_RENDER_CONTEXT } from \"./useGridVirtualization.js\";\nimport { gridRowSpanningHiddenCellsOriginMapSelector } from \"../rows/gridRowSpanningSelectors.js\";\nimport { gridListColumnSelector } from \"../listView/gridListViewSelectors.js\";\nimport { minimalContentHeight } from \"../rows/gridRowsUtils.js\";\nimport { EMPTY_PINNED_COLUMN_FIELDS } from \"../columns/index.js\";\nimport { gridFocusedVirtualCellSelector } from \"./gridFocusedVirtualCellSelector.js\";\nimport { roundToDecimalPlaces } from \"../../../utils/roundToDecimalPlaces.js\";\nimport { isJSDOM } from \"../../../utils/isJSDOM.js\";\nimport { gridRowSelectionManagerSelector } from \"../rowSelection/index.js\";\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nconst MINIMUM_COLUMN_WIDTH = 50;\nvar ScrollDirection = /*#__PURE__*/function (ScrollDirection) {\n  ScrollDirection[ScrollDirection[\"NONE\"] = 0] = \"NONE\";\n  ScrollDirection[ScrollDirection[\"UP\"] = 1] = \"UP\";\n  ScrollDirection[ScrollDirection[\"DOWN\"] = 2] = \"DOWN\";\n  ScrollDirection[ScrollDirection[\"LEFT\"] = 3] = \"LEFT\";\n  ScrollDirection[ScrollDirection[\"RIGHT\"] = 4] = \"RIGHT\";\n  return ScrollDirection;\n}(ScrollDirection || {});\nconst EMPTY_SCROLL_POSITION = {\n  top: 0,\n  left: 0\n};\nexport const EMPTY_DETAIL_PANELS = Object.freeze(new Map());\nconst createScrollCache = (isRtl, rowBufferPx, columnBufferPx, verticalBuffer, horizontalBuffer) => ({\n  direction: ScrollDirection.NONE,\n  buffer: bufferForDirection(isRtl, ScrollDirection.NONE, rowBufferPx, columnBufferPx, verticalBuffer, horizontalBuffer)\n});\nexport const useGridVirtualScroller = () => {\n  const apiRef = useGridPrivateApiContext();\n  const rootProps = useGridRootProps();\n  const {\n    listView\n  } = rootProps;\n  const visibleColumns = useGridSelector(apiRef, () => listView ? [gridListColumnSelector(apiRef)] : gridVisibleColumnDefinitionsSelector(apiRef));\n  const enabledForRows = useGridSelector(apiRef, gridVirtualizationRowEnabledSelector) && !isJSDOM;\n  const enabledForColumns = useGridSelector(apiRef, gridVirtualizationColumnEnabledSelector) && !isJSDOM;\n  const pinnedRows = useGridSelector(apiRef, gridPinnedRowsSelector);\n  const pinnedColumnDefinitions = gridVisiblePinnedColumnDefinitionsSelector(apiRef);\n  const pinnedColumns = listView ? EMPTY_PINNED_COLUMN_FIELDS : pinnedColumnDefinitions;\n  const hasBottomPinnedRows = pinnedRows.bottom.length > 0;\n  const [panels, setPanels] = React.useState(EMPTY_DETAIL_PANELS);\n  const isRtl = useRtl();\n  const rowSelectionManager = useGridSelector(apiRef, gridRowSelectionManagerSelector);\n  const currentPage = useGridVisibleRows(apiRef);\n  const mainRef = apiRef.current.mainElementRef;\n  const scrollerRef = apiRef.current.virtualScrollerRef;\n  const scrollbarVerticalRef = apiRef.current.virtualScrollbarVerticalRef;\n  const scrollbarHorizontalRef = apiRef.current.virtualScrollbarHorizontalRef;\n  const hasColSpan = useGridSelector(apiRef, gridHasColSpanSelector);\n  const isRenderContextReady = React.useRef(false);\n  const rowHeight = useGridSelector(apiRef, gridRowHeightSelector);\n  const contentHeight = useGridSelector(apiRef, gridContentHeightSelector);\n  const columnsTotalWidth = useGridSelector(apiRef, gridColumnsTotalWidthSelector);\n  const needsHorizontalScrollbar = useGridSelector(apiRef, needsHorizontalScrollbarSelector);\n  const verticalScrollbarWidth = useGridSelector(apiRef, gridVerticalScrollbarWidthSelector);\n  const gridHasFiller = useGridSelector(apiRef, gridHasFillerSelector);\n  const previousSize = React.useRef(null);\n  const mainRefCallback = React.useCallback(node => {\n    mainRef.current = node;\n    if (!node) {\n      return undefined;\n    }\n    const initialRect = node.getBoundingClientRect();\n    let lastSize = {\n      width: roundToDecimalPlaces(initialRect.width, 1),\n      height: roundToDecimalPlaces(initialRect.height, 1)\n    };\n    if (!previousSize.current || lastSize.width !== previousSize.current.width && lastSize.height !== previousSize.current.height) {\n      previousSize.current = lastSize;\n      apiRef.current.publishEvent('resize', lastSize);\n    }\n    if (typeof ResizeObserver === 'undefined') {\n      return undefined;\n    }\n    const observer = new ResizeObserver(entries => {\n      const entry = entries[0];\n      if (!entry) {\n        return;\n      }\n      const newSize = {\n        width: roundToDecimalPlaces(entry.contentRect.width, 1),\n        height: roundToDecimalPlaces(entry.contentRect.height, 1)\n      };\n      if (newSize.width === lastSize.width && newSize.height === lastSize.height) {\n        return;\n      }\n      apiRef.current.publishEvent('resize', newSize);\n      lastSize = newSize;\n    });\n    observer.observe(node);\n    if (reactMajor >= 19) {\n      return () => {\n        mainRef.current = null;\n        observer.disconnect();\n      };\n    }\n    return undefined;\n  }, [apiRef, mainRef]);\n\n  /*\n   * Scroll context logic\n   * ====================\n   * We only render the cells contained in the `renderContext`. However, when the user starts scrolling the grid\n   * in a direction, we want to render as many cells as possible in that direction, as to avoid presenting white\n   * areas if the user scrolls too fast/far and the viewport ends up in a region we haven't rendered yet. To render\n   * more cells, we store some offsets to add to the viewport in `scrollCache.buffer`. Those offsets make the render\n   * context wider in the direction the user is going, but also makes the buffer around the viewport `0` for the\n   * dimension (horizontal or vertical) in which the user is not scrolling. So if the normal viewport is 8 columns\n   * wide, with a 1 column buffer (10 columns total), then we want it to be exactly 8 columns wide during vertical\n   * scroll.\n   * However, we don't want the rows in the old context to re-render from e.g. 10 columns to 8 columns, because that's\n   * work that's not necessary. Thus we store the context at the start of the scroll in `frozenContext`, and the rows\n   * that are part of this old context will keep their same render context as to avoid re-rendering.\n   */\n  const scrollPosition = React.useRef(rootProps.initialState?.scroll ?? EMPTY_SCROLL_POSITION);\n  const ignoreNextScrollEvent = React.useRef(false);\n  const previousContextScrollPosition = React.useRef(EMPTY_SCROLL_POSITION);\n  const previousRowContext = React.useRef(EMPTY_RENDER_CONTEXT);\n  const renderContext = useGridSelector(apiRef, gridRenderContextSelector);\n  const focusedVirtualCell = useGridSelector(apiRef, gridFocusedVirtualCellSelector);\n  const scrollTimeout = useTimeout();\n  const frozenContext = React.useRef(undefined);\n  const scrollCache = useLazyRef(() => createScrollCache(isRtl, rootProps.rowBufferPx, rootProps.columnBufferPx, rowHeight * 15, MINIMUM_COLUMN_WIDTH * 6)).current;\n  const updateRenderContext = React.useCallback(nextRenderContext => {\n    if (areRenderContextsEqual(nextRenderContext, apiRef.current.state.virtualization.renderContext)) {\n      return;\n    }\n    const didRowsIntervalChange = nextRenderContext.firstRowIndex !== previousRowContext.current.firstRowIndex || nextRenderContext.lastRowIndex !== previousRowContext.current.lastRowIndex;\n    apiRef.current.setState(state => {\n      return _extends({}, state, {\n        virtualization: _extends({}, state.virtualization, {\n          renderContext: nextRenderContext\n        })\n      });\n    });\n\n    // The lazy-loading hook is listening to `renderedRowsIntervalChange`,\n    // but only does something if we already have a render context, because\n    // otherwise we would call an update directly on mount\n    const isReady = gridDimensionsSelector(apiRef).isReady;\n    if (isReady && didRowsIntervalChange) {\n      previousRowContext.current = nextRenderContext;\n      apiRef.current.publishEvent('renderedRowsIntervalChange', nextRenderContext);\n    }\n    previousContextScrollPosition.current = scrollPosition.current;\n  }, [apiRef]);\n  const triggerUpdateRenderContext = useEventCallback(() => {\n    const scroller = scrollerRef.current;\n    if (!scroller) {\n      return undefined;\n    }\n    const dimensions = gridDimensionsSelector(apiRef);\n    const maxScrollTop = Math.ceil(dimensions.minimumSize.height - dimensions.viewportOuterSize.height);\n    const maxScrollLeft = Math.ceil(dimensions.minimumSize.width - dimensions.viewportInnerSize.width);\n\n    // Clamp the scroll position to the viewport to avoid re-calculating the render context for scroll bounce\n    const newScroll = {\n      top: clamp(scroller.scrollTop, 0, maxScrollTop),\n      left: isRtl ? clamp(scroller.scrollLeft, -maxScrollLeft, 0) : clamp(scroller.scrollLeft, 0, maxScrollLeft)\n    };\n    const dx = newScroll.left - scrollPosition.current.left;\n    const dy = newScroll.top - scrollPosition.current.top;\n    const isScrolling = dx !== 0 || dy !== 0;\n    scrollPosition.current = newScroll;\n    const direction = isScrolling ? directionForDelta(dx, dy) : ScrollDirection.NONE;\n\n    // Since previous render, we have scrolled...\n    const rowScroll = Math.abs(scrollPosition.current.top - previousContextScrollPosition.current.top);\n    const columnScroll = Math.abs(scrollPosition.current.left - previousContextScrollPosition.current.left);\n\n    // PERF: use the computed minimum column width instead of a static one\n    const didCrossThreshold = rowScroll >= rowHeight || columnScroll >= MINIMUM_COLUMN_WIDTH;\n    const didChangeDirection = scrollCache.direction !== direction;\n    const shouldUpdate = didCrossThreshold || didChangeDirection;\n    if (!shouldUpdate) {\n      return renderContext;\n    }\n\n    // Render a new context\n\n    if (didChangeDirection) {\n      switch (direction) {\n        case ScrollDirection.NONE:\n        case ScrollDirection.LEFT:\n        case ScrollDirection.RIGHT:\n          frozenContext.current = undefined;\n          break;\n        default:\n          frozenContext.current = renderContext;\n          break;\n      }\n    }\n    scrollCache.direction = direction;\n    scrollCache.buffer = bufferForDirection(isRtl, direction, rootProps.rowBufferPx, rootProps.columnBufferPx, rowHeight * 15, MINIMUM_COLUMN_WIDTH * 6);\n    const inputs = inputsSelector(apiRef, rootProps, enabledForRows, enabledForColumns);\n    const nextRenderContext = computeRenderContext(inputs, scrollPosition.current, scrollCache);\n\n    // Prevents batching render context changes\n    ReactDOM.flushSync(() => {\n      updateRenderContext(nextRenderContext);\n    });\n    scrollTimeout.start(1000, triggerUpdateRenderContext);\n    return nextRenderContext;\n  });\n  const forceUpdateRenderContext = () => {\n    // skip update if dimensions are not ready and virtualization is enabled\n    if (!gridDimensionsSelector(apiRef).isReady && (enabledForRows || enabledForColumns)) {\n      return;\n    }\n    const inputs = inputsSelector(apiRef, rootProps, enabledForRows, enabledForColumns);\n    const nextRenderContext = computeRenderContext(inputs, scrollPosition.current, scrollCache);\n    // Reset the frozen context when the render context changes, see the illustration in https://github.com/mui/mui-x/pull/12353\n    frozenContext.current = undefined;\n    updateRenderContext(nextRenderContext);\n  };\n  const handleScroll = useEventCallback(() => {\n    if (ignoreNextScrollEvent.current) {\n      ignoreNextScrollEvent.current = false;\n      return;\n    }\n    const nextRenderContext = triggerUpdateRenderContext();\n    apiRef.current.publishEvent('scrollPositionChange', {\n      top: scrollPosition.current.top,\n      left: scrollPosition.current.left,\n      renderContext: nextRenderContext\n    });\n  });\n  const handleWheel = useEventCallback(event => {\n    apiRef.current.publishEvent('virtualScrollerWheel', {}, event);\n  });\n  const handleTouchMove = useEventCallback(event => {\n    apiRef.current.publishEvent('virtualScrollerTouchMove', {}, event);\n  });\n  const getRows = (params = {}) => {\n    if (!params.rows && !currentPage.range) {\n      return [];\n    }\n    const rowTree = gridRowTreeSelector(apiRef);\n    let baseRenderContext = renderContext;\n    if (params.renderContext) {\n      baseRenderContext = params.renderContext;\n      baseRenderContext.firstColumnIndex = renderContext.firstColumnIndex;\n      baseRenderContext.lastColumnIndex = renderContext.lastColumnIndex;\n    }\n    const isLastSection = !hasBottomPinnedRows && params.position === undefined || hasBottomPinnedRows && params.position === 'bottom';\n    const isPinnedSection = params.position !== undefined;\n    let rowIndexOffset;\n    // FIXME: Why is the switch check exhaustiveness not validated with typescript-eslint?\n    // eslint-disable-next-line default-case\n    switch (params.position) {\n      case 'top':\n        rowIndexOffset = 0;\n        break;\n      case 'bottom':\n        rowIndexOffset = pinnedRows.top.length + currentPage.rows.length;\n        break;\n      case undefined:\n        rowIndexOffset = pinnedRows.top.length;\n        break;\n    }\n    const rowModels = params.rows ?? currentPage.rows;\n    const firstRowToRender = baseRenderContext.firstRowIndex;\n    const lastRowToRender = Math.min(baseRenderContext.lastRowIndex, rowModels.length);\n    const rowIndexes = params.rows ? range(0, params.rows.length) : range(firstRowToRender, lastRowToRender);\n    let virtualRowIndex = -1;\n    if (!isPinnedSection && focusedVirtualCell) {\n      if (focusedVirtualCell.rowIndex < firstRowToRender) {\n        rowIndexes.unshift(focusedVirtualCell.rowIndex);\n        virtualRowIndex = focusedVirtualCell.rowIndex;\n      }\n      if (focusedVirtualCell.rowIndex > lastRowToRender) {\n        rowIndexes.push(focusedVirtualCell.rowIndex);\n        virtualRowIndex = focusedVirtualCell.rowIndex;\n      }\n    }\n    const rows = [];\n    const rowProps = rootProps.slotProps?.row;\n    const columnPositions = gridColumnPositionsSelector(apiRef);\n    rowIndexes.forEach(rowIndexInPage => {\n      const {\n        id,\n        model\n      } = rowModels[rowIndexInPage];\n\n      // In certain cases, the state might already be updated and `currentPage.rows` (which sets `rowModels`)\n      // contains stale data.\n      // In that case, skip any further row processing.\n      // See:\n      // - https://github.com/mui/mui-x/issues/16638\n      // - https://github.com/mui/mui-x/issues/17022\n      if (!rowTree[id]) {\n        return;\n      }\n      const rowIndex = (currentPage?.range?.firstRowIndex || 0) + rowIndexOffset + rowIndexInPage;\n\n      // NOTE: This is an expensive feature, the colSpan code could be optimized.\n      if (hasColSpan) {\n        const minFirstColumn = pinnedColumns.left.length;\n        const maxLastColumn = visibleColumns.length - pinnedColumns.right.length;\n        apiRef.current.calculateColSpan({\n          rowId: id,\n          minFirstColumn,\n          maxLastColumn,\n          columns: visibleColumns\n        });\n        if (pinnedColumns.left.length > 0) {\n          apiRef.current.calculateColSpan({\n            rowId: id,\n            minFirstColumn: 0,\n            maxLastColumn: pinnedColumns.left.length,\n            columns: visibleColumns\n          });\n        }\n        if (pinnedColumns.right.length > 0) {\n          apiRef.current.calculateColSpan({\n            rowId: id,\n            minFirstColumn: visibleColumns.length - pinnedColumns.right.length,\n            maxLastColumn: visibleColumns.length,\n            columns: visibleColumns\n          });\n        }\n      }\n      const baseRowHeight = !apiRef.current.rowHasAutoHeight(id) ? apiRef.current.unstable_getRowHeight(id) : 'auto';\n      const isSelected = rowSelectionManager.has(id) && apiRef.current.isRowSelectable(id);\n      let isFirstVisible = false;\n      if (params.position === undefined) {\n        isFirstVisible = rowIndexInPage === 0;\n      }\n      let isLastVisible = false;\n      const isLastVisibleInSection = rowIndexInPage === rowModels.length - 1;\n      if (isLastSection) {\n        if (!isPinnedSection) {\n          const lastIndex = currentPage.rows.length - 1;\n          const isLastVisibleRowIndex = rowIndexInPage === lastIndex;\n          if (isLastVisibleRowIndex) {\n            isLastVisible = true;\n          }\n        } else {\n          isLastVisible = isLastVisibleInSection;\n        }\n      }\n      let currentRenderContext = baseRenderContext;\n      if (frozenContext.current && rowIndexInPage >= frozenContext.current.firstRowIndex && rowIndexInPage < frozenContext.current.lastRowIndex) {\n        currentRenderContext = frozenContext.current;\n      }\n      const isVirtualFocusRow = rowIndexInPage === virtualRowIndex;\n      const isVirtualFocusColumn = focusedVirtualCell?.rowIndex === rowIndex;\n      const offsetLeft = computeOffsetLeft(columnPositions, currentRenderContext, pinnedColumns.left.length);\n      const showBottomBorder = isLastVisibleInSection && params.position === 'top';\n      const firstColumnIndex = currentRenderContext.firstColumnIndex;\n      const lastColumnIndex = currentRenderContext.lastColumnIndex;\n      rows.push(/*#__PURE__*/_jsx(rootProps.slots.row, _extends({\n        row: model,\n        rowId: id,\n        index: rowIndex,\n        selected: isSelected,\n        offsetLeft: offsetLeft,\n        columnsTotalWidth: columnsTotalWidth,\n        rowHeight: baseRowHeight,\n        pinnedColumns: pinnedColumns,\n        visibleColumns: visibleColumns,\n        firstColumnIndex: firstColumnIndex,\n        lastColumnIndex: lastColumnIndex,\n        focusedColumnIndex: isVirtualFocusColumn ? focusedVirtualCell.columnIndex : undefined,\n        isFirstVisible: isFirstVisible,\n        isLastVisible: isLastVisible,\n        isNotVisible: isVirtualFocusRow,\n        showBottomBorder: showBottomBorder,\n        scrollbarWidth: verticalScrollbarWidth,\n        gridHasFiller: gridHasFiller\n      }, rowProps), id));\n      if (isVirtualFocusRow) {\n        return;\n      }\n      const panel = panels.get(id);\n      if (panel) {\n        rows.push(panel);\n      }\n      if (params.position === undefined && isLastVisibleInSection) {\n        rows.push(apiRef.current.getInfiniteLoadingTriggerElement?.({\n          lastRowId: id\n        }));\n      }\n    });\n    return rows;\n  };\n  const scrollerStyle = React.useMemo(() => ({\n    overflowX: !needsHorizontalScrollbar || listView ? 'hidden' : undefined,\n    overflowY: rootProps.autoHeight ? 'hidden' : undefined\n  }), [needsHorizontalScrollbar, rootProps.autoHeight, listView]);\n  const contentSize = React.useMemo(() => {\n    const size = {\n      width: needsHorizontalScrollbar ? columnsTotalWidth : 'auto',\n      flexBasis: contentHeight,\n      flexShrink: 0\n    };\n    if (size.flexBasis === 0) {\n      size.flexBasis = minimalContentHeight; // Give room to show the overlay when there no rows.\n    }\n    return size;\n  }, [columnsTotalWidth, contentHeight, needsHorizontalScrollbar]);\n  const onContentSizeApplied = React.useCallback(node => {\n    if (!node) {\n      return;\n    }\n    apiRef.current.publishEvent('virtualScrollerContentSizeChange', {\n      columnsTotalWidth,\n      contentHeight\n    });\n  }, [apiRef, columnsTotalWidth, contentHeight]);\n  useEnhancedEffect(() => {\n    if (!isRenderContextReady.current) {\n      return;\n    }\n    apiRef.current.updateRenderContext?.();\n  }, [apiRef, enabledForColumns, enabledForRows]);\n  useEnhancedEffect(() => {\n    if (listView) {\n      scrollerRef.current.scrollLeft = 0;\n    }\n  }, [listView, scrollerRef]);\n  useRunOnce(renderContext !== EMPTY_RENDER_CONTEXT, () => {\n    apiRef.current.publishEvent('scrollPositionChange', {\n      top: scrollPosition.current.top,\n      left: scrollPosition.current.left,\n      renderContext\n    });\n    isRenderContextReady.current = true;\n    if (rootProps.initialState?.scroll && scrollerRef.current) {\n      const scroller = scrollerRef.current;\n      const {\n        top,\n        left\n      } = rootProps.initialState.scroll;\n\n      // On initial mount, if we have columns available, we can restore the horizontal scroll immediately, but we need to skip the resulting scroll event, otherwise we would recalculate the render context at position top=0, left=restoredValue, but the initial render context is already calculated based on the initial value of scrollPosition ref.\n      const isScrollRestored = {\n        top: !(top > 0),\n        left: !(left > 0)\n      };\n      if (!isScrollRestored.left && columnsTotalWidth) {\n        scroller.scrollLeft = left;\n        ignoreNextScrollEvent.current = true;\n        isScrollRestored.left = true;\n      }\n\n      // For the sake of completeness, but I'm not sure if contentHeight is ever available at this point. Maybe when virtualisation is disabled?\n      if (!isScrollRestored.top && contentHeight) {\n        scroller.scrollTop = top;\n        ignoreNextScrollEvent.current = true;\n        isScrollRestored.top = true;\n      }\n\n      // To restore the vertical scroll, we need to wait until the rows are available in the DOM (otherwise there's nowhere to scroll), but before paint to avoid reflows\n      if (!isScrollRestored.top || !isScrollRestored.left) {\n        const unsubscribeContentSizeChange = apiRef.current.subscribeEvent('virtualScrollerContentSizeChange', params => {\n          if (!isScrollRestored.left && params.columnsTotalWidth) {\n            scroller.scrollLeft = left;\n            ignoreNextScrollEvent.current = true;\n            isScrollRestored.left = true;\n          }\n          if (!isScrollRestored.top && params.contentHeight) {\n            scroller.scrollTop = top;\n            ignoreNextScrollEvent.current = true;\n            isScrollRestored.top = true;\n          }\n          if (isScrollRestored.left && isScrollRestored.top) {\n            unsubscribeContentSizeChange();\n          }\n        });\n        return unsubscribeContentSizeChange;\n      }\n    }\n    return undefined;\n  });\n  apiRef.current.register('private', {\n    updateRenderContext: forceUpdateRenderContext\n  });\n  useGridEventPriority(apiRef, 'sortedRowsSet', forceUpdateRenderContext);\n  useGridEventPriority(apiRef, 'paginationModelChange', forceUpdateRenderContext);\n  useGridEventPriority(apiRef, 'columnsChange', forceUpdateRenderContext);\n  return {\n    renderContext,\n    setPanels,\n    getRows,\n    getContainerProps: () => ({\n      ref: mainRefCallback\n    }),\n    getScrollerProps: () => ({\n      ref: scrollerRef,\n      onScroll: handleScroll,\n      onWheel: handleWheel,\n      onTouchMove: handleTouchMove,\n      style: scrollerStyle,\n      role: 'presentation',\n      // `tabIndex` shouldn't be used along role=presentation, but it fixes a Firefox bug\n      // https://github.com/mui/mui-x/pull/13891#discussion_r1683416024\n      tabIndex: platform.isFirefox ? -1 : undefined\n    }),\n    getContentProps: () => ({\n      style: contentSize,\n      role: 'presentation',\n      ref: onContentSizeApplied\n    }),\n    getRenderZoneProps: () => ({\n      role: 'rowgroup'\n    }),\n    getScrollbarVerticalProps: () => ({\n      ref: scrollbarVerticalRef,\n      scrollPosition\n    }),\n    getScrollbarHorizontalProps: () => ({\n      ref: scrollbarHorizontalRef,\n      scrollPosition\n    }),\n    getScrollAreaProps: () => ({\n      scrollPosition\n    })\n  };\n};\n// dimension selectors\nfunction needsHorizontalScrollbarSelector(apiRef) {\n  return apiRef.current.state.dimensions.viewportOuterSize.width > 0 && apiRef.current.state.dimensions.columnsTotalWidth > apiRef.current.state.dimensions.viewportOuterSize.width;\n}\nfunction inputsSelector(apiRef, rootProps, enabledForRows, enabledForColumns) {\n  const dimensions = gridDimensionsSelector(apiRef);\n  const currentPage = getVisibleRows(apiRef, rootProps);\n  const visibleColumns = rootProps.listView ? [gridListColumnSelector(apiRef)] : gridVisibleColumnDefinitionsSelector(apiRef);\n  const hiddenCellsOriginMap = gridRowSpanningHiddenCellsOriginMapSelector(apiRef);\n  const lastRowId = apiRef.current.state.rows.dataRowIds.at(-1);\n  const lastColumn = visibleColumns.at(-1);\n  return {\n    enabledForRows,\n    enabledForColumns,\n    apiRef,\n    autoHeight: rootProps.autoHeight,\n    rowBufferPx: rootProps.rowBufferPx,\n    columnBufferPx: rootProps.columnBufferPx,\n    leftPinnedWidth: dimensions.leftPinnedWidth,\n    columnsTotalWidth: dimensions.columnsTotalWidth,\n    viewportInnerWidth: dimensions.viewportInnerSize.width,\n    viewportInnerHeight: dimensions.viewportInnerSize.height,\n    lastRowHeight: lastRowId !== undefined ? apiRef.current.unstable_getRowHeight(lastRowId) : 0,\n    lastColumnWidth: lastColumn?.computedWidth ?? 0,\n    rowsMeta: gridRowsMetaSelector(apiRef),\n    columnPositions: gridColumnPositionsSelector(apiRef),\n    rows: currentPage.rows,\n    range: currentPage.range,\n    pinnedColumns: gridVisiblePinnedColumnDefinitionsSelector(apiRef),\n    visibleColumns,\n    hiddenCellsOriginMap,\n    listView: rootProps.listView ?? false,\n    virtualizeColumnsWithAutoRowHeight: rootProps.virtualizeColumnsWithAutoRowHeight\n  };\n}\nfunction computeRenderContext(inputs, scrollPosition, scrollCache) {\n  const renderContext = {\n    firstRowIndex: 0,\n    lastRowIndex: inputs.rows.length,\n    firstColumnIndex: 0,\n    lastColumnIndex: inputs.visibleColumns.length\n  };\n  const {\n    top,\n    left\n  } = scrollPosition;\n  const realLeft = Math.abs(left) + inputs.leftPinnedWidth;\n  if (inputs.enabledForRows) {\n    // Clamp the value because the search may return an index out of bounds.\n    // In the last index, this is not needed because Array.slice doesn't include it.\n    let firstRowIndex = Math.min(getNearestIndexToRender(inputs, top, {\n      atStart: true,\n      lastPosition: inputs.rowsMeta.positions[inputs.rowsMeta.positions.length - 1] + inputs.lastRowHeight\n    }), inputs.rowsMeta.positions.length - 1);\n\n    // If any of the cells in the `firstRowIndex` is hidden due to an extended row span,\n    // Make sure the row from where the rowSpan is originated is visible.\n    const rowSpanHiddenCellOrigin = inputs.hiddenCellsOriginMap[firstRowIndex];\n    if (rowSpanHiddenCellOrigin) {\n      const minSpannedRowIndex = Math.min(...Object.values(rowSpanHiddenCellOrigin));\n      firstRowIndex = Math.min(firstRowIndex, minSpannedRowIndex);\n    }\n    const lastRowIndex = inputs.autoHeight ? firstRowIndex + inputs.rows.length : getNearestIndexToRender(inputs, top + inputs.viewportInnerHeight);\n    renderContext.firstRowIndex = firstRowIndex;\n    renderContext.lastRowIndex = lastRowIndex;\n  }\n  if (inputs.listView) {\n    return _extends({}, renderContext, {\n      lastColumnIndex: 1\n    });\n  }\n  if (inputs.enabledForColumns) {\n    let firstColumnIndex = 0;\n    let lastColumnIndex = inputs.columnPositions.length;\n    let hasRowWithAutoHeight = false;\n    const [firstRowToRender, lastRowToRender] = getIndexesToRender({\n      firstIndex: renderContext.firstRowIndex,\n      lastIndex: renderContext.lastRowIndex,\n      minFirstIndex: 0,\n      maxLastIndex: inputs.rows.length,\n      bufferBefore: scrollCache.buffer.rowBefore,\n      bufferAfter: scrollCache.buffer.rowAfter,\n      positions: inputs.rowsMeta.positions,\n      lastSize: inputs.lastRowHeight\n    });\n    if (!inputs.virtualizeColumnsWithAutoRowHeight) {\n      for (let i = firstRowToRender; i < lastRowToRender && !hasRowWithAutoHeight; i += 1) {\n        const row = inputs.rows[i];\n        hasRowWithAutoHeight = inputs.apiRef.current.rowHasAutoHeight(row.id);\n      }\n    }\n    if (!hasRowWithAutoHeight || inputs.virtualizeColumnsWithAutoRowHeight) {\n      firstColumnIndex = binarySearch(realLeft, inputs.columnPositions, {\n        atStart: true,\n        lastPosition: inputs.columnsTotalWidth\n      });\n      lastColumnIndex = binarySearch(realLeft + inputs.viewportInnerWidth, inputs.columnPositions);\n    }\n    renderContext.firstColumnIndex = firstColumnIndex;\n    renderContext.lastColumnIndex = lastColumnIndex;\n  }\n  const actualRenderContext = deriveRenderContext(inputs, renderContext, scrollCache);\n  return actualRenderContext;\n}\nfunction getNearestIndexToRender(inputs, offset, options) {\n  const lastMeasuredIndexRelativeToAllRows = inputs.apiRef.current.getLastMeasuredRowIndex();\n  let allRowsMeasured = lastMeasuredIndexRelativeToAllRows === Infinity;\n  if (inputs.range?.lastRowIndex && !allRowsMeasured) {\n    // Check if all rows in this page are already measured\n    allRowsMeasured = lastMeasuredIndexRelativeToAllRows >= inputs.range.lastRowIndex;\n  }\n  const lastMeasuredIndexRelativeToCurrentPage = clamp(lastMeasuredIndexRelativeToAllRows - (inputs.range?.firstRowIndex || 0), 0, inputs.rowsMeta.positions.length);\n  if (allRowsMeasured || inputs.rowsMeta.positions[lastMeasuredIndexRelativeToCurrentPage] >= offset) {\n    // If all rows were measured (when no row has \"auto\" as height) or all rows before the offset\n    // were measured, then use a binary search because it's faster.\n    return binarySearch(offset, inputs.rowsMeta.positions, options);\n  }\n\n  // Otherwise, use an exponential search.\n  // If rows have \"auto\" as height, their positions will be based on estimated heights.\n  // In this case, we can skip several steps until we find a position higher than the offset.\n  // Inspired by https://github.com/bvaughn/react-virtualized/blob/master/source/Grid/utils/CellSizeAndPositionManager.js\n  return exponentialSearch(offset, inputs.rowsMeta.positions, lastMeasuredIndexRelativeToCurrentPage, options);\n}\n\n/**\n * Accepts as input a raw render context (the area visible in the viewport) and adds\n * computes the actual render context based on pinned elements, buffer dimensions and\n * spanning.\n */\nfunction deriveRenderContext(inputs, nextRenderContext, scrollCache) {\n  const [firstRowToRender, lastRowToRender] = getIndexesToRender({\n    firstIndex: nextRenderContext.firstRowIndex,\n    lastIndex: nextRenderContext.lastRowIndex,\n    minFirstIndex: 0,\n    maxLastIndex: inputs.rows.length,\n    bufferBefore: scrollCache.buffer.rowBefore,\n    bufferAfter: scrollCache.buffer.rowAfter,\n    positions: inputs.rowsMeta.positions,\n    lastSize: inputs.lastRowHeight\n  });\n  const [initialFirstColumnToRender, lastColumnToRender] = getIndexesToRender({\n    firstIndex: nextRenderContext.firstColumnIndex,\n    lastIndex: nextRenderContext.lastColumnIndex,\n    minFirstIndex: inputs.pinnedColumns.left.length,\n    maxLastIndex: inputs.visibleColumns.length - inputs.pinnedColumns.right.length,\n    bufferBefore: scrollCache.buffer.columnBefore,\n    bufferAfter: scrollCache.buffer.columnAfter,\n    positions: inputs.columnPositions,\n    lastSize: inputs.lastColumnWidth\n  });\n  const firstColumnToRender = getFirstNonSpannedColumnToRender({\n    firstColumnToRender: initialFirstColumnToRender,\n    apiRef: inputs.apiRef,\n    firstRowToRender,\n    lastRowToRender,\n    visibleRows: inputs.rows\n  });\n  return {\n    firstRowIndex: firstRowToRender,\n    lastRowIndex: lastRowToRender,\n    firstColumnIndex: firstColumnToRender,\n    lastColumnIndex: lastColumnToRender\n  };\n}\n/**\n * Use binary search to avoid looping through all possible positions.\n * The `options.atStart` provides the possibility to match for the first element that\n * intersects the screen, even if said element's start position is before `offset`. In\n * other words, we search for `offset + width`.\n */\nfunction binarySearch(offset, positions, options = undefined, sliceStart = 0, sliceEnd = positions.length) {\n  if (positions.length <= 0) {\n    return -1;\n  }\n  if (sliceStart >= sliceEnd) {\n    return sliceStart;\n  }\n  const pivot = sliceStart + Math.floor((sliceEnd - sliceStart) / 2);\n  const position = positions[pivot];\n  let isBefore;\n  if (options?.atStart) {\n    const width = (pivot === positions.length - 1 ? options.lastPosition : positions[pivot + 1]) - position;\n    isBefore = offset - width < position;\n  } else {\n    isBefore = offset <= position;\n  }\n  return isBefore ? binarySearch(offset, positions, options, sliceStart, pivot) : binarySearch(offset, positions, options, pivot + 1, sliceEnd);\n}\nfunction exponentialSearch(offset, positions, index, options = undefined) {\n  let interval = 1;\n  while (index < positions.length && Math.abs(positions[index]) < offset) {\n    index += interval;\n    interval *= 2;\n  }\n  return binarySearch(offset, positions, options, Math.floor(index / 2), Math.min(index, positions.length));\n}\nfunction getIndexesToRender({\n  firstIndex,\n  lastIndex,\n  bufferBefore,\n  bufferAfter,\n  minFirstIndex,\n  maxLastIndex,\n  positions,\n  lastSize\n}) {\n  const firstPosition = positions[firstIndex] - bufferBefore;\n  const lastPosition = positions[lastIndex] + bufferAfter;\n  const firstIndexPadded = binarySearch(firstPosition, positions, {\n    atStart: true,\n    lastPosition: positions[positions.length - 1] + lastSize\n  });\n  const lastIndexPadded = binarySearch(lastPosition, positions);\n  return [clamp(firstIndexPadded, minFirstIndex, maxLastIndex), clamp(lastIndexPadded, minFirstIndex, maxLastIndex)];\n}\nexport function areRenderContextsEqual(context1, context2) {\n  if (context1 === context2) {\n    return true;\n  }\n  return context1.firstRowIndex === context2.firstRowIndex && context1.lastRowIndex === context2.lastRowIndex && context1.firstColumnIndex === context2.firstColumnIndex && context1.lastColumnIndex === context2.lastColumnIndex;\n}\nexport function computeOffsetLeft(columnPositions, renderContext, pinnedLeftLength) {\n  const left = (columnPositions[renderContext.firstColumnIndex] ?? 0) - (columnPositions[pinnedLeftLength] ?? 0);\n  return Math.abs(left);\n}\nfunction directionForDelta(dx, dy) {\n  if (dx === 0 && dy === 0) {\n    return ScrollDirection.NONE;\n  }\n  /* eslint-disable */\n  if (Math.abs(dy) >= Math.abs(dx)) {\n    if (dy > 0) {\n      return ScrollDirection.DOWN;\n    } else {\n      return ScrollDirection.UP;\n    }\n  } else {\n    if (dx > 0) {\n      return ScrollDirection.RIGHT;\n    } else {\n      return ScrollDirection.LEFT;\n    }\n  }\n  /* eslint-enable */\n}\nfunction bufferForDirection(isRtl, direction, rowBufferPx, columnBufferPx, verticalBuffer, horizontalBuffer) {\n  if (isRtl) {\n    switch (direction) {\n      case ScrollDirection.LEFT:\n        direction = ScrollDirection.RIGHT;\n        break;\n      case ScrollDirection.RIGHT:\n        direction = ScrollDirection.LEFT;\n        break;\n      default:\n    }\n  }\n  switch (direction) {\n    case ScrollDirection.NONE:\n      return {\n        rowAfter: rowBufferPx,\n        rowBefore: rowBufferPx,\n        columnAfter: columnBufferPx,\n        columnBefore: columnBufferPx\n      };\n    case ScrollDirection.LEFT:\n      return {\n        rowAfter: 0,\n        rowBefore: 0,\n        columnAfter: 0,\n        columnBefore: horizontalBuffer\n      };\n    case ScrollDirection.RIGHT:\n      return {\n        rowAfter: 0,\n        rowBefore: 0,\n        columnAfter: horizontalBuffer,\n        columnBefore: 0\n      };\n    case ScrollDirection.UP:\n      return {\n        rowAfter: 0,\n        rowBefore: verticalBuffer,\n        columnAfter: 0,\n        columnBefore: 0\n      };\n    case ScrollDirection.DOWN:\n      return {\n        rowAfter: verticalBuffer,\n        rowBefore: 0,\n        columnAfter: 0,\n        columnBefore: 0\n      };\n    default:\n      // eslint unable to figure out enum exhaustiveness\n      throw new Error('unreachable');\n  }\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}