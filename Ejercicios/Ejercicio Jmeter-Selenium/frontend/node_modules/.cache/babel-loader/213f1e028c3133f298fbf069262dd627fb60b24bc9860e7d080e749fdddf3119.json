{"ast":null,"code":"import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport * as React from 'react';\nimport useLazyRef from '@mui/utils/useLazyRef';\nimport { unstable_useEnhancedEffect as useEnhancedEffect } from '@mui/utils';\nimport { ResizeObserver } from \"../../../utils/ResizeObserver.js\";\nimport { useGridVisibleRows } from \"../../utils/useGridVisibleRows.js\";\nimport { eslintUseValue } from \"../../../utils/utils.js\";\nimport { useGridApiMethod } from \"../../utils/useGridApiMethod.js\";\nimport { useGridSelector } from \"../../utils/useGridSelector.js\";\nimport { gridDensityFactorSelector } from \"../density/densitySelector.js\";\nimport { gridPaginationSelector } from \"../pagination/gridPaginationSelector.js\";\nimport { useGridRegisterPipeApplier } from \"../../core/pipeProcessing/index.js\";\nimport { gridPinnedRowsSelector, gridRowCountSelector } from \"./gridRowsSelector.js\";\nimport { gridDimensionsSelector, gridRowHeightSelector } from \"../dimensions/gridDimensionsSelectors.js\";\nimport { getValidRowHeight, getRowHeightWarning } from \"./gridRowsUtils.js\";\nimport { gridFocusedVirtualCellSelector } from \"../virtualization/gridFocusedVirtualCellSelector.js\";\n/* eslint-disable no-underscore-dangle */\n\nexport const rowsMetaStateInitializer = (state, props, apiRef) => {\n  apiRef.current.caches.rowsMeta = {\n    heights: new Map()\n  };\n  const baseRowHeight = gridRowHeightSelector(apiRef);\n  const dataRowCount = gridRowCountSelector(apiRef);\n  const pagination = gridPaginationSelector(apiRef);\n  const rowCount = Math.min(pagination.enabled ? pagination.paginationModel.pageSize : dataRowCount, dataRowCount);\n  return _extends({}, state, {\n    rowsMeta: {\n      currentPageTotalHeight: rowCount * baseRowHeight,\n      positions: Array.from({\n        length: rowCount\n      }, (_, i) => i * baseRowHeight),\n      pinnedTopRowsTotalHeight: 0,\n      pinnedBottomRowsTotalHeight: 0\n    }\n  });\n};\n\n/**\n * @requires useGridPageSize (method)\n * @requires useGridPage (method)\n */\nexport const useGridRowsMeta = (apiRef, props) => {\n  const {\n    getRowHeight: getRowHeightProp,\n    getRowSpacing,\n    getEstimatedRowHeight\n  } = props;\n  const heightCache = apiRef.current.caches.rowsMeta.heights;\n  const lastMeasuredRowIndex = React.useRef(-1);\n  const hasRowWithAutoHeight = React.useRef(false);\n  const isHeightMetaValid = React.useRef(false);\n  const densityFactor = useGridSelector(apiRef, gridDensityFactorSelector);\n  const currentPage = useGridVisibleRows(apiRef, props);\n  const pinnedRows = useGridSelector(apiRef, gridPinnedRowsSelector);\n  const rowHeight = useGridSelector(apiRef, gridRowHeightSelector);\n  const getRowHeightEntry = rowId => {\n    let entry = heightCache.get(rowId);\n    if (entry === undefined) {\n      entry = {\n        content: rowHeight,\n        spacingTop: 0,\n        spacingBottom: 0,\n        detail: 0,\n        autoHeight: false,\n        needsFirstMeasurement: true\n      };\n      heightCache.set(rowId, entry);\n    }\n    return entry;\n  };\n  const processHeightEntry = React.useCallback(row => {\n    // HACK: rowHeight trails behind the most up-to-date value just enough to\n    // mess the initial rowsMeta hydration :/\n    const baseRowHeight = gridDimensionsSelector(apiRef).rowHeight;\n    eslintUseValue(rowHeight);\n    const entry = apiRef.current.getRowHeightEntry(row.id);\n    if (!getRowHeightProp) {\n      entry.content = baseRowHeight;\n      entry.needsFirstMeasurement = false;\n    } else {\n      const rowHeightFromUser = getRowHeightProp(_extends({}, row, {\n        densityFactor\n      }));\n      if (rowHeightFromUser === 'auto') {\n        if (entry.needsFirstMeasurement) {\n          const estimatedRowHeight = getEstimatedRowHeight ? getEstimatedRowHeight(_extends({}, row, {\n            densityFactor\n          })) : baseRowHeight;\n\n          // If the row was not measured yet use the estimated row height\n          entry.content = estimatedRowHeight ?? baseRowHeight;\n        }\n        hasRowWithAutoHeight.current = true;\n        entry.autoHeight = true;\n      } else {\n        // Default back to base rowHeight if getRowHeight returns invalid value.\n        entry.content = getValidRowHeight(rowHeightFromUser, baseRowHeight, getRowHeightWarning);\n        entry.needsFirstMeasurement = false;\n        entry.autoHeight = false;\n      }\n    }\n    if (getRowSpacing) {\n      const indexRelativeToCurrentPage = apiRef.current.getRowIndexRelativeToVisibleRows(row.id);\n      const spacing = getRowSpacing(_extends({}, row, {\n        isFirstVisible: indexRelativeToCurrentPage === 0,\n        isLastVisible: indexRelativeToCurrentPage === currentPage.rows.length - 1,\n        indexRelativeToCurrentPage\n      }));\n      entry.spacingTop = spacing.top ?? 0;\n      entry.spacingBottom = spacing.bottom ?? 0;\n    } else {\n      entry.spacingTop = 0;\n      entry.spacingBottom = 0;\n    }\n    apiRef.current.unstable_applyPipeProcessors('rowHeight', entry, row);\n    return entry;\n  }, [apiRef, currentPage.rows, getRowHeightProp, getEstimatedRowHeight, rowHeight, getRowSpacing, densityFactor]);\n  const hydrateRowsMeta = React.useCallback(() => {\n    hasRowWithAutoHeight.current = false;\n    const pinnedTopRowsTotalHeight = pinnedRows.top.reduce((acc, row) => {\n      const entry = processHeightEntry(row);\n      return acc + entry.content + entry.spacingTop + entry.spacingBottom + entry.detail;\n    }, 0);\n    const pinnedBottomRowsTotalHeight = pinnedRows.bottom.reduce((acc, row) => {\n      const entry = processHeightEntry(row);\n      return acc + entry.content + entry.spacingTop + entry.spacingBottom + entry.detail;\n    }, 0);\n    const positions = [];\n    const currentPageTotalHeight = currentPage.rows.reduce((acc, row) => {\n      positions.push(acc);\n      const entry = processHeightEntry(row);\n      const total = entry.content + entry.spacingTop + entry.spacingBottom + entry.detail;\n      return acc + total;\n    }, 0);\n    if (!hasRowWithAutoHeight.current) {\n      // No row has height=auto, so all rows are already measured\n      lastMeasuredRowIndex.current = Infinity;\n    }\n    const didHeightsChange = pinnedTopRowsTotalHeight !== apiRef.current.state.rowsMeta.pinnedTopRowsTotalHeight || pinnedBottomRowsTotalHeight !== apiRef.current.state.rowsMeta.pinnedBottomRowsTotalHeight || currentPageTotalHeight !== apiRef.current.state.rowsMeta.currentPageTotalHeight;\n    const rowsMeta = {\n      currentPageTotalHeight,\n      positions,\n      pinnedTopRowsTotalHeight,\n      pinnedBottomRowsTotalHeight\n    };\n    apiRef.current.setState(state => {\n      return _extends({}, state, {\n        rowsMeta\n      });\n    });\n    if (didHeightsChange) {\n      apiRef.current.updateDimensions();\n    }\n    isHeightMetaValid.current = true;\n  }, [apiRef, pinnedRows, currentPage.rows, processHeightEntry]);\n  const getRowHeight = rowId => {\n    return heightCache.get(rowId)?.content ?? rowHeight;\n  };\n  const storeRowHeightMeasurement = (id, height) => {\n    const entry = apiRef.current.getRowHeightEntry(id);\n    const didChange = entry.content !== height;\n    entry.needsFirstMeasurement = false;\n    entry.content = height;\n    isHeightMetaValid.current &&= !didChange;\n  };\n  const rowHasAutoHeight = id => {\n    return heightCache.get(id)?.autoHeight ?? false;\n  };\n  const getLastMeasuredRowIndex = () => {\n    return lastMeasuredRowIndex.current;\n  };\n  const setLastMeasuredRowIndex = index => {\n    if (hasRowWithAutoHeight.current && index > lastMeasuredRowIndex.current) {\n      lastMeasuredRowIndex.current = index;\n    }\n  };\n  const resetRowHeights = () => {\n    heightCache.clear();\n    hydrateRowsMeta();\n  };\n  const resizeObserver = useLazyRef(() => new ResizeObserver(entries => {\n    for (let i = 0; i < entries.length; i += 1) {\n      const entry = entries[i];\n      const height = entry.borderBoxSize && entry.borderBoxSize.length > 0 ? entry.borderBoxSize[0].blockSize : entry.contentRect.height;\n      const rowId = entry.target.__mui_id;\n      const focusedVirtualRowId = gridFocusedVirtualCellSelector(apiRef)?.id;\n      if (focusedVirtualRowId === rowId && height === 0) {\n        // Focused virtual row has 0 height.\n        // We don't want to store it to avoid scroll jumping.\n        // https://github.com/mui/mui-x/issues/14726\n        return;\n      }\n      apiRef.current.unstable_storeRowHeightMeasurement(rowId, height);\n    }\n    if (!isHeightMetaValid.current) {\n      apiRef.current.requestPipeProcessorsApplication('rowHeight');\n    }\n  })).current;\n  const observeRowHeight = (element, rowId) => {\n    element.__mui_id = rowId;\n    resizeObserver.observe(element);\n    return () => resizeObserver.unobserve(element);\n  };\n  useGridRegisterPipeApplier(apiRef, 'rowHeight', hydrateRowsMeta);\n\n  // The effect is used to build the rows meta data - currentPageTotalHeight and positions.\n  // Because of variable row height this is needed for the virtualization\n  useEnhancedEffect(() => {\n    hydrateRowsMeta();\n  }, [hydrateRowsMeta]);\n  const rowsMetaApi = {\n    unstable_getRowHeight: getRowHeight,\n    unstable_setLastMeasuredRowIndex: setLastMeasuredRowIndex,\n    unstable_storeRowHeightMeasurement: storeRowHeightMeasurement,\n    resetRowHeights\n  };\n  const rowsMetaPrivateApi = {\n    hydrateRowsMeta,\n    observeRowHeight,\n    rowHasAutoHeight,\n    getRowHeightEntry,\n    getLastMeasuredRowIndex\n  };\n  useGridApiMethod(apiRef, rowsMetaApi, 'public');\n  useGridApiMethod(apiRef, rowsMetaPrivateApi, 'private');\n};","map":{"version":3,"names":["_extends","React","useLazyRef","unstable_useEnhancedEffect","useEnhancedEffect","ResizeObserver","useGridVisibleRows","eslintUseValue","useGridApiMethod","useGridSelector","gridDensityFactorSelector","gridPaginationSelector","useGridRegisterPipeApplier","gridPinnedRowsSelector","gridRowCountSelector","gridDimensionsSelector","gridRowHeightSelector","getValidRowHeight","getRowHeightWarning","gridFocusedVirtualCellSelector","rowsMetaStateInitializer","state","props","apiRef","current","caches","rowsMeta","heights","Map","baseRowHeight","dataRowCount","pagination","rowCount","Math","min","enabled","paginationModel","pageSize","currentPageTotalHeight","positions","Array","from","length","_","i","pinnedTopRowsTotalHeight","pinnedBottomRowsTotalHeight","useGridRowsMeta","getRowHeight","getRowHeightProp","getRowSpacing","getEstimatedRowHeight","heightCache","lastMeasuredRowIndex","useRef","hasRowWithAutoHeight","isHeightMetaValid","densityFactor","currentPage","pinnedRows","rowHeight","getRowHeightEntry","rowId","entry","get","undefined","content","spacingTop","spacingBottom","detail","autoHeight","needsFirstMeasurement","set","processHeightEntry","useCallback","row","id","rowHeightFromUser","estimatedRowHeight","indexRelativeToCurrentPage","getRowIndexRelativeToVisibleRows","spacing","isFirstVisible","isLastVisible","rows","top","bottom","unstable_applyPipeProcessors","hydrateRowsMeta","reduce","acc","push","total","Infinity","didHeightsChange","setState","updateDimensions","storeRowHeightMeasurement","height","didChange","rowHasAutoHeight","getLastMeasuredRowIndex","setLastMeasuredRowIndex","index","resetRowHeights","clear","resizeObserver","entries","borderBoxSize","blockSize","contentRect","target","__mui_id","focusedVirtualRowId","unstable_storeRowHeightMeasurement","requestPipeProcessorsApplication","observeRowHeight","element","observe","unobserve","rowsMetaApi","unstable_getRowHeight","unstable_setLastMeasuredRowIndex","rowsMetaPrivateApi"],"sources":["D:/2025/Calidad de Software/calidadMACG/Ejercicios/Ejercicio Jmeter-Selenium/frontend/node_modules/@mui/x-data-grid/esm/hooks/features/rows/useGridRowsMeta.js"],"sourcesContent":["import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport * as React from 'react';\nimport useLazyRef from '@mui/utils/useLazyRef';\nimport { unstable_useEnhancedEffect as useEnhancedEffect } from '@mui/utils';\nimport { ResizeObserver } from \"../../../utils/ResizeObserver.js\";\nimport { useGridVisibleRows } from \"../../utils/useGridVisibleRows.js\";\nimport { eslintUseValue } from \"../../../utils/utils.js\";\nimport { useGridApiMethod } from \"../../utils/useGridApiMethod.js\";\nimport { useGridSelector } from \"../../utils/useGridSelector.js\";\nimport { gridDensityFactorSelector } from \"../density/densitySelector.js\";\nimport { gridPaginationSelector } from \"../pagination/gridPaginationSelector.js\";\nimport { useGridRegisterPipeApplier } from \"../../core/pipeProcessing/index.js\";\nimport { gridPinnedRowsSelector, gridRowCountSelector } from \"./gridRowsSelector.js\";\nimport { gridDimensionsSelector, gridRowHeightSelector } from \"../dimensions/gridDimensionsSelectors.js\";\nimport { getValidRowHeight, getRowHeightWarning } from \"./gridRowsUtils.js\";\nimport { gridFocusedVirtualCellSelector } from \"../virtualization/gridFocusedVirtualCellSelector.js\";\n/* eslint-disable no-underscore-dangle */\n\nexport const rowsMetaStateInitializer = (state, props, apiRef) => {\n  apiRef.current.caches.rowsMeta = {\n    heights: new Map()\n  };\n  const baseRowHeight = gridRowHeightSelector(apiRef);\n  const dataRowCount = gridRowCountSelector(apiRef);\n  const pagination = gridPaginationSelector(apiRef);\n  const rowCount = Math.min(pagination.enabled ? pagination.paginationModel.pageSize : dataRowCount, dataRowCount);\n  return _extends({}, state, {\n    rowsMeta: {\n      currentPageTotalHeight: rowCount * baseRowHeight,\n      positions: Array.from({\n        length: rowCount\n      }, (_, i) => i * baseRowHeight),\n      pinnedTopRowsTotalHeight: 0,\n      pinnedBottomRowsTotalHeight: 0\n    }\n  });\n};\n\n/**\n * @requires useGridPageSize (method)\n * @requires useGridPage (method)\n */\nexport const useGridRowsMeta = (apiRef, props) => {\n  const {\n    getRowHeight: getRowHeightProp,\n    getRowSpacing,\n    getEstimatedRowHeight\n  } = props;\n  const heightCache = apiRef.current.caches.rowsMeta.heights;\n  const lastMeasuredRowIndex = React.useRef(-1);\n  const hasRowWithAutoHeight = React.useRef(false);\n  const isHeightMetaValid = React.useRef(false);\n  const densityFactor = useGridSelector(apiRef, gridDensityFactorSelector);\n  const currentPage = useGridVisibleRows(apiRef, props);\n  const pinnedRows = useGridSelector(apiRef, gridPinnedRowsSelector);\n  const rowHeight = useGridSelector(apiRef, gridRowHeightSelector);\n  const getRowHeightEntry = rowId => {\n    let entry = heightCache.get(rowId);\n    if (entry === undefined) {\n      entry = {\n        content: rowHeight,\n        spacingTop: 0,\n        spacingBottom: 0,\n        detail: 0,\n        autoHeight: false,\n        needsFirstMeasurement: true\n      };\n      heightCache.set(rowId, entry);\n    }\n    return entry;\n  };\n  const processHeightEntry = React.useCallback(row => {\n    // HACK: rowHeight trails behind the most up-to-date value just enough to\n    // mess the initial rowsMeta hydration :/\n    const baseRowHeight = gridDimensionsSelector(apiRef).rowHeight;\n    eslintUseValue(rowHeight);\n    const entry = apiRef.current.getRowHeightEntry(row.id);\n    if (!getRowHeightProp) {\n      entry.content = baseRowHeight;\n      entry.needsFirstMeasurement = false;\n    } else {\n      const rowHeightFromUser = getRowHeightProp(_extends({}, row, {\n        densityFactor\n      }));\n      if (rowHeightFromUser === 'auto') {\n        if (entry.needsFirstMeasurement) {\n          const estimatedRowHeight = getEstimatedRowHeight ? getEstimatedRowHeight(_extends({}, row, {\n            densityFactor\n          })) : baseRowHeight;\n\n          // If the row was not measured yet use the estimated row height\n          entry.content = estimatedRowHeight ?? baseRowHeight;\n        }\n        hasRowWithAutoHeight.current = true;\n        entry.autoHeight = true;\n      } else {\n        // Default back to base rowHeight if getRowHeight returns invalid value.\n        entry.content = getValidRowHeight(rowHeightFromUser, baseRowHeight, getRowHeightWarning);\n        entry.needsFirstMeasurement = false;\n        entry.autoHeight = false;\n      }\n    }\n    if (getRowSpacing) {\n      const indexRelativeToCurrentPage = apiRef.current.getRowIndexRelativeToVisibleRows(row.id);\n      const spacing = getRowSpacing(_extends({}, row, {\n        isFirstVisible: indexRelativeToCurrentPage === 0,\n        isLastVisible: indexRelativeToCurrentPage === currentPage.rows.length - 1,\n        indexRelativeToCurrentPage\n      }));\n      entry.spacingTop = spacing.top ?? 0;\n      entry.spacingBottom = spacing.bottom ?? 0;\n    } else {\n      entry.spacingTop = 0;\n      entry.spacingBottom = 0;\n    }\n    apiRef.current.unstable_applyPipeProcessors('rowHeight', entry, row);\n    return entry;\n  }, [apiRef, currentPage.rows, getRowHeightProp, getEstimatedRowHeight, rowHeight, getRowSpacing, densityFactor]);\n  const hydrateRowsMeta = React.useCallback(() => {\n    hasRowWithAutoHeight.current = false;\n    const pinnedTopRowsTotalHeight = pinnedRows.top.reduce((acc, row) => {\n      const entry = processHeightEntry(row);\n      return acc + entry.content + entry.spacingTop + entry.spacingBottom + entry.detail;\n    }, 0);\n    const pinnedBottomRowsTotalHeight = pinnedRows.bottom.reduce((acc, row) => {\n      const entry = processHeightEntry(row);\n      return acc + entry.content + entry.spacingTop + entry.spacingBottom + entry.detail;\n    }, 0);\n    const positions = [];\n    const currentPageTotalHeight = currentPage.rows.reduce((acc, row) => {\n      positions.push(acc);\n      const entry = processHeightEntry(row);\n      const total = entry.content + entry.spacingTop + entry.spacingBottom + entry.detail;\n      return acc + total;\n    }, 0);\n    if (!hasRowWithAutoHeight.current) {\n      // No row has height=auto, so all rows are already measured\n      lastMeasuredRowIndex.current = Infinity;\n    }\n    const didHeightsChange = pinnedTopRowsTotalHeight !== apiRef.current.state.rowsMeta.pinnedTopRowsTotalHeight || pinnedBottomRowsTotalHeight !== apiRef.current.state.rowsMeta.pinnedBottomRowsTotalHeight || currentPageTotalHeight !== apiRef.current.state.rowsMeta.currentPageTotalHeight;\n    const rowsMeta = {\n      currentPageTotalHeight,\n      positions,\n      pinnedTopRowsTotalHeight,\n      pinnedBottomRowsTotalHeight\n    };\n    apiRef.current.setState(state => {\n      return _extends({}, state, {\n        rowsMeta\n      });\n    });\n    if (didHeightsChange) {\n      apiRef.current.updateDimensions();\n    }\n    isHeightMetaValid.current = true;\n  }, [apiRef, pinnedRows, currentPage.rows, processHeightEntry]);\n  const getRowHeight = rowId => {\n    return heightCache.get(rowId)?.content ?? rowHeight;\n  };\n  const storeRowHeightMeasurement = (id, height) => {\n    const entry = apiRef.current.getRowHeightEntry(id);\n    const didChange = entry.content !== height;\n    entry.needsFirstMeasurement = false;\n    entry.content = height;\n    isHeightMetaValid.current &&= !didChange;\n  };\n  const rowHasAutoHeight = id => {\n    return heightCache.get(id)?.autoHeight ?? false;\n  };\n  const getLastMeasuredRowIndex = () => {\n    return lastMeasuredRowIndex.current;\n  };\n  const setLastMeasuredRowIndex = index => {\n    if (hasRowWithAutoHeight.current && index > lastMeasuredRowIndex.current) {\n      lastMeasuredRowIndex.current = index;\n    }\n  };\n  const resetRowHeights = () => {\n    heightCache.clear();\n    hydrateRowsMeta();\n  };\n  const resizeObserver = useLazyRef(() => new ResizeObserver(entries => {\n    for (let i = 0; i < entries.length; i += 1) {\n      const entry = entries[i];\n      const height = entry.borderBoxSize && entry.borderBoxSize.length > 0 ? entry.borderBoxSize[0].blockSize : entry.contentRect.height;\n      const rowId = entry.target.__mui_id;\n      const focusedVirtualRowId = gridFocusedVirtualCellSelector(apiRef)?.id;\n      if (focusedVirtualRowId === rowId && height === 0) {\n        // Focused virtual row has 0 height.\n        // We don't want to store it to avoid scroll jumping.\n        // https://github.com/mui/mui-x/issues/14726\n        return;\n      }\n      apiRef.current.unstable_storeRowHeightMeasurement(rowId, height);\n    }\n    if (!isHeightMetaValid.current) {\n      apiRef.current.requestPipeProcessorsApplication('rowHeight');\n    }\n  })).current;\n  const observeRowHeight = (element, rowId) => {\n    element.__mui_id = rowId;\n    resizeObserver.observe(element);\n    return () => resizeObserver.unobserve(element);\n  };\n  useGridRegisterPipeApplier(apiRef, 'rowHeight', hydrateRowsMeta);\n\n  // The effect is used to build the rows meta data - currentPageTotalHeight and positions.\n  // Because of variable row height this is needed for the virtualization\n  useEnhancedEffect(() => {\n    hydrateRowsMeta();\n  }, [hydrateRowsMeta]);\n  const rowsMetaApi = {\n    unstable_getRowHeight: getRowHeight,\n    unstable_setLastMeasuredRowIndex: setLastMeasuredRowIndex,\n    unstable_storeRowHeightMeasurement: storeRowHeightMeasurement,\n    resetRowHeights\n  };\n  const rowsMetaPrivateApi = {\n    hydrateRowsMeta,\n    observeRowHeight,\n    rowHasAutoHeight,\n    getRowHeightEntry,\n    getLastMeasuredRowIndex\n  };\n  useGridApiMethod(apiRef, rowsMetaApi, 'public');\n  useGridApiMethod(apiRef, rowsMetaPrivateApi, 'private');\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}